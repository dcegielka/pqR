
pqR version 2.15.1 (2018-00-00), based on R 2.15.0 (2012-03-30)

R 2.15.0 is Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

Modifications to R in pqR are Copyright (C) 2013-2018 Radford M. Neal

Some modules are from R-2.15.1 or later versions distributed by the R Core Team

Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.


No helper threads, task merging enabled, uncompressed pointers.

> # Test gradient computations.
> #
> # Added for pqR, 2018 Radford M. Neal.
> 
> 
> # Check consistency of simple math derivatives using track_gradient with 'D'
> 
> x <- 0.32739
> 
> print (identical (track_gradient (x) gradient_of (sqrt(x)),
+                   eval (D (quote (sqrt(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (exp(x)),
+                   eval (D (quote (exp(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (expm1(x)),
+                   eval (D (quote (expm1(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (log1p(x)),
+                   eval (D (quote (log1p(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (log(x)),
+                   eval (D (quote (log(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (cos(x)),
+                   eval (D (quote (cos(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (sin(x)),
+                   eval (D (quote (sin(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (tan(x)),
+                   eval (D (quote (tan(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (acos(x)),
+                   eval (D (quote (acos(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (asin(x)),
+                   eval (D (quote (asin(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (cosh(x)),
+                   eval (D (quote (cosh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (sinh(x)),
+                   eval (D (quote (sinh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (tanh(x)),
+                   eval (D (quote (tanh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (lgamma(x)),
+                   eval (D (quote (lgamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (gamma(x)),
+                   eval (D (quote (gamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (digamma(x)),
+                   eval (D (quote (digamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (trigamma(x)),
+                   eval (D (quote (trigamma (x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (+x),
+                   eval (D (quote (+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (-x),
+                   eval (D (quote (-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1+x),
+                   eval (D (quote (3.1+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1-x),
+                   eval (D (quote (3.1-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1*x),
+                   eval (D (quote (3.1*x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1/x),
+                   eval (D (quote (3.1/x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1^x),
+                   eval (D (quote (3.1^x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x+3.1),
+                   eval (D (quote (x+3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x-3.1),
+                   eval (D (quote (x-3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x*3.1),
+                   eval (D (quote (x*3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x/3.1),
+                   eval (D (quote (x/3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x^3.1),
+                   eval (D (quote (x^3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x+x),
+                   eval (D (quote (x+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x-x),
+                   eval (D (quote (x-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x*x),
+                   eval (D (quote (x*x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x/x),
+                   eval (D (quote (x/x), "x")) ))
[1] TRUE
> 
> print (identical (round (track_gradient (x) gradient_of (x^x), 14),
+                   round (eval (D (quote (x^x), "x")), 14) ))
[1] TRUE
> 
> 
> # Check gradient computations passing through mathematical function dispatch.
> 
> a <- 256; class(a) <- "fred"
> cos.fred <- function (x) tan(x)
> log2.fred <- function (x) tan(tan(x))
> Math.fred <- function (x,...) {
+     if (.Generic=="log") sqrt(x)
+     else if (.Generic=="log10") sqrt(sqrt(x))
+     else if (.Generic=="exp") sqrt(sqrt(sqrt(x)))
+     else NextMethod()
+ }
> 
> print(cos(a))
[1] 25.11156
attr(,"class")
[1] "fred"
> print(log2(a))
[1] -0.02118493
attr(,"class")
[1] "fred"
> print(log(a))
[1] 16
attr(,"class")
[1] "fred"
> print(log10(a))
[1] 4
attr(,"class")
[1] "fred"
> print(exp(a))
[1] 2
attr(,"class")
[1] "fred"
> print(sin(a))
[1] -0.999208
attr(,"class")
[1] "fred"
> 
> print (with_gradient (a) cos(a))
[1] 25.11156
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 631.5904
> print (with_gradient (a) log2(a))
[1] -0.02118493
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 631.8739
> print (with_gradient (a) log(a))
[1] 16
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.03125
> print (with_gradient (a) log10(a))
[1] 4
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.00390625
> print (with_gradient (a) exp(a))
[1] 2
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.0009765625
> print (with_gradient (a) sin(a))
[1] -0.999208
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] -0.03979076
> 
> 
> # Check consistency of results between with_gradient and numericDeriv.
> 
> x <- 0.32739
> x1 <- 0.89472; x2 <- 0.49718
> i1 <- 3
> 
> bindgrads <- function (r1,r2) 
+     cbind (rbind(r1,r2), rbind(attr(r1,"gradient"),attr(r2,"gradient")))
> 
> test1 <- function (fun,...)
+     print (bindgrads (numericDeriv(quote(fun(x,...)),"x"),
+                       with_gradient (x) fun(x,...)))
> 
> test2 <- function (fun,...) {
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),"x1"),
+                       with_gradient (x1) fun(x1,x2,...)))
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),"x2"),
+                       with_gradient (x2) fun(x1,x2,...)))
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),c("x1","x2")),
+       { r <- with_gradient (x1) { s <- with_gradient (x2) fun(x1,x2,...); 
+                                   g2 <<- attr(s,"gradient"); s }
+         attr(r,"gradient") <- cbind(g1=attr(r,"gradient"),g2=g2)
+         r
+       }
+     ))
+ }
> 
> test2i <- function (fun,...) {
+     print (bindgrads (numericDeriv(quote(fun(i1,x2,...)),"x2"),
+                       with_gradient (x2) fun(i1,x2,...)))
+ }
> 
> test1(sin)
        [,1]      [,2]
r1 0.3215728 0.9468849
r2 0.3215728 0.9468849
> 
> test1(log)
        [,1]     [,2]
r1 -1.116603 3.054461
r2 -1.116603 3.054461
> 
> test1(gamma)
       [,1]      [,2]
r1 2.729765 -8.716212
r2 2.729765 -8.716212
> 
> test2(atan2)
       [,1]      [,2]
r1 1.063601 0.4745389
r2 1.063601 0.4745389
       [,1]       [,2]
r1 1.063601 -0.8539753
r2 1.063601 -0.8539753
                   g1         g2
r1 1.063601 0.4745389 -0.8539753
r2 1.063601 0.4745389 -0.8539753
> 
> test2(dexp)
       [,1]       [,2]
r1 0.318657 -0.1584299
r2 0.318657 -0.1584299
       [,1]    [,2]
r1 0.318657 0.35582
r2 0.318657 0.35582
                    g1      g2
r1 0.318657 -0.1584299 0.35582
r2 0.318657 -0.1584299 0.35582
> 
> test2(dexp,log=TRUE)
       [,1]     [,2]
r1 -1.14364 -0.49718
r2 -1.14364 -0.49718
       [,1]     [,2]
r1 -1.14364 1.116624
r2 -1.14364 1.116624
                  g1       g2
r1 -1.14364 -0.49718 1.116624
r2 -1.14364 -0.49718 1.116624
> 
> test2i(dgeom)
         [,1]       [,2]
r1 0.06320498 -0.2499760
r2 0.06320498 -0.2499761
> 
> test2i(dgeom,log=TRUE)
        [,1]      [,2]
r1 -2.761372 -3.955006
r2 -2.761372 -3.955006
> 
