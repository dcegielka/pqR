
pqR version 2.15.1 (2018-00-00), based on R 2.15.0 (2012-03-30)

R 2.15.0 is Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0

Modifications to R in pqR are Copyright (C) 2013-2018 Radford M. Neal

Some modules are from R-2.15.1 or later versions distributed by the R Core Team

Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.


No helper threads, task merging enabled, uncompressed pointers.

> # Test gradient computations.
> #
> # Added for pqR, 2018 Radford M. Neal.
> 
> 
> # Check consistency of simple math derivatives using track_gradient with 'D'
> 
> x <- 0.32739
> 
> print (identical (track_gradient (x) gradient_of (sqrt(x)),
+                   eval (D (quote (sqrt(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (exp(x)),
+                   eval (D (quote (exp(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (expm1(x)),
+                   eval (D (quote (expm1(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (log1p(x)),
+                   eval (D (quote (log1p(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (log(x)),
+                   eval (D (quote (log(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (cos(x)),
+                   eval (D (quote (cos(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (sin(x)),
+                   eval (D (quote (sin(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (tan(x)),
+                   eval (D (quote (tan(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (acos(x)),
+                   eval (D (quote (acos(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (asin(x)),
+                   eval (D (quote (asin(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (cosh(x)),
+                   eval (D (quote (cosh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (sinh(x)),
+                   eval (D (quote (sinh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (tanh(x)),
+                   eval (D (quote (tanh(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (lgamma(x)),
+                   eval (D (quote (lgamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (gamma(x)),
+                   eval (D (quote (gamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (digamma(x)),
+                   eval (D (quote (digamma(x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (trigamma(x)),
+                   eval (D (quote (trigamma (x)), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (+x),
+                   eval (D (quote (+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (-x),
+                   eval (D (quote (-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1+x),
+                   eval (D (quote (3.1+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1-x),
+                   eval (D (quote (3.1-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1*x),
+                   eval (D (quote (3.1*x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1/x),
+                   eval (D (quote (3.1/x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (3.1^x),
+                   eval (D (quote (3.1^x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x+3.1),
+                   eval (D (quote (x+3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x-3.1),
+                   eval (D (quote (x-3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x*3.1),
+                   eval (D (quote (x*3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x/3.1),
+                   eval (D (quote (x/3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x^3.1),
+                   eval (D (quote (x^3.1), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x+x),
+                   eval (D (quote (x+x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x-x),
+                   eval (D (quote (x-x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x*x),
+                   eval (D (quote (x*x), "x")) ))
[1] TRUE
> 
> print (identical (track_gradient (x) gradient_of (x/x),
+                   eval (D (quote (x/x), "x")) ))
[1] TRUE
> 
> print (identical (round (track_gradient (x) gradient_of (x^x), 14),
+                   round (eval (D (quote (x^x), "x")), 14) ))
[1] TRUE
> 
> 
> # Check gradient computations passing through mathematical function dispatch.
> 
> a <- 256; class(a) <- "fred"
> cos.fred <- function (x) tan(x)
> log2.fred <- function (x) tan(tan(x))
> Math.fred <- function (x,...) {
+     if (.Generic=="log") sqrt(x)
+     else if (.Generic=="log10") sqrt(sqrt(x))
+     else if (.Generic=="exp") sqrt(sqrt(sqrt(x)))
+     else NextMethod()
+ }
> 
> print(cos(a))
[1] 25.11156
attr(,"class")
[1] "fred"
> print(log2(a))
[1] -0.02118493
attr(,"class")
[1] "fred"
> print(log(a))
[1] 16
attr(,"class")
[1] "fred"
> print(log10(a))
[1] 4
attr(,"class")
[1] "fred"
> print(exp(a))
[1] 2
attr(,"class")
[1] "fred"
> print(sin(a))
[1] -0.999208
attr(,"class")
[1] "fred"
> 
> print (with_gradient (a) cos(a))
[1] 25.11156
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 631.5904
> print (with_gradient (a) log2(a))
[1] -0.02118493
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 631.8739
> print (with_gradient (a) log(a))
[1] 16
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.03125
> print (with_gradient (a) log10(a))
[1] 4
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.00390625
> print (with_gradient (a) exp(a))
[1] 2
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] 0.0009765625
> print (with_gradient (a) sin(a))
[1] -0.999208
attr(,"class")
[1] "fred"
attr(,"gradient")
[1] -0.03979076
> 
> 
> # Check consistency of results between with_gradient and numericDeriv.
> 
> x <- 0.32739
> x1 <- 0.47718; x2 <- 0.89472
> i1 <- 3
> 
> bindgrads <- function (r1,r2) 
+     cbind (rbind(r1,r2), rbind(attr(r1,"gradient"),unlist(attr(r2,"gradient"))))
> 
> test1 <- function (fun,...)
+     print (bindgrads (numericDeriv(quote(fun(x,...)),"x"),
+                       with_gradient (x) fun(x,...)))
> test1p1 <- function (fun,...)
+     print (bindgrads (numericDeriv(quote(fun(x+1,...)),"x"),
+                       with_gradient (x) fun(x+1,...)))
> 
> test1r <- function (fun,...) {
+     f <- function (x) { set.seed(179); fun(1,x,...) }
+     print (bindgrads (numericDeriv(quote(f(x)),"x"),
+                       with_gradient (x) f(x)))
+ }
> 
> test2 <- function (fun,...) {
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),"x1"),
+                       with_gradient (x1) fun(x1,x2,...)))
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),"x2"),
+                       with_gradient (x2) fun(x1,x2,...)))
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),c("x1","x2")),
+                       with_gradient (x1,x2) fun(x1,x2,...)))
+     print (bindgrads (numericDeriv(quote(fun(x1,x2,...)),c("x1","x2")),
+       { r <- with_gradient (x1) { s <- with_gradient (x2) fun(x1,x2,...); 
+                                   g2 <<- attr(s,"gradient"); s }
+         attr(r,"gradient") <- cbind(g1=attr(r,"gradient"),g2=g2)
+         r
+       }
+     ))
+ }
> 
> test2i <- function (fun,...) {
+     print (bindgrads (numericDeriv(quote(fun(i1,x2,...)),"x2"),
+                       with_gradient (x2) fun(i1,x2,...)))
+ }
> 
> test2r <- function (fun,...) {
+     f <- function (x1,x2) { set.seed(179); fun(1,x1,x2,...) }
+     print (bindgrads (numericDeriv(quote(f(x1,x2)),c("x1","x2")),
+                       with_gradient (x1,x2) f(x1,x2)))
+ }
> 
> test1(abs)
      [,1] [,2]
r1 0.32739    1
r2 0.32739    1
> 
> test1(sqrt)
      [,1]      [,2]
r1 0.57218 0.8738508
r2 0.57218 0.8738508
> 
> test1(exp)
       [,1]     [,2]
r1 1.387342 1.387342
r2 1.387342 1.387342
> test1(expm1)
        [,1]     [,2]
r1 0.3873424 1.387342
r2 0.3873424 1.387342
> 
> test1(log1p)
        [,1]      [,2]
r1 0.2832146 0.7533581
r2 0.2832146 0.7533581
> test1(log)
        [,1]     [,2]
r1 -1.116603 3.054461
r2 -1.116603 3.054461
> test1(log2)
        [,1]     [,2]
r1 -1.610918 4.406656
r2 -1.610918 4.406656
> test1(log10)
         [,1]     [,2]
r1 -0.4849346 1.326536
r2 -0.4849346 1.326536
> 
> test1(cos)
        [,1]       [,2]
r1 0.9468849 -0.3215728
r2 0.9468849 -0.3215728
> test1(sin)
        [,1]      [,2]
r1 0.3215728 0.9468849
r2 0.3215728 0.9468849
> test1(tan)
        [,1]     [,2]
r1 0.3396113 1.115336
r2 0.3396113 1.115336
> 
> test1(acos)
       [,1]      [,2]
r1 1.237256 -1.058325
r2 1.237256 -1.058325
> test1(asin)
      [,1]     [,2]
r1 0.33354 1.058325
r2 0.33354 1.058325
> test1(atan)
        [,1]      [,2]
r1 0.3163921 0.9031921
r2 0.3163921 0.9031921
> 
> test1(cosh)
       [,1]      [,2]
r1 1.054073 0.3332699
r2 1.054073 0.3332699
> test1(sinh)
        [,1]     [,2]
r1 0.3332699 1.054073
r2 0.3332699 1.054073
> test1(tanh)
        [,1]      [,2]
r1 0.3161736 0.9000342
r2 0.3161736 0.9000342
> 
> test1p1(acosh)
        [,1]     [,2]
r1 0.7885917 1.145599
r2 0.7885917 1.145599
> test1(asinh)
        [,1]      [,2]
r1 0.3218068 0.9503642
r2 0.3218068 0.9503642
> test1(atanh)
        [,1]     [,2]
r1 0.3399021 1.120052
r2 0.3399021 1.120052
> 
> test1(gamma)
       [,1]      [,2]
r1 2.729765 -8.716212
r2 2.729765 -8.716212
> test1(lgamma)
       [,1]      [,2]
r1 1.004216 -3.193026
r2 1.004216 -3.193026
> test1(digamma)
        [,1]     [,2]
r1 -3.193026 10.43204
r2 -3.193026 10.43204
> test1(trigamma)
       [,1]      [,2]
r1 10.43204 -58.12982
r2 10.43204 -58.12982
> 
> test2(atan2)
        [,1]      [,2]
r1 0.4899538 0.8701601
r2 0.4899538 0.8701601
        [,1]       [,2]
r1 0.4899538 -0.4640815
r2 0.4899538 -0.4640815
                    x1         x2
r1 0.4899538 0.8701601 -0.4640815
r2 0.4899538 0.8701601 -0.4640815
                    g1         g2
r1 0.4899538 0.8701601 -0.4640815
r2 0.4899538 0.8701601 -0.4640815
> 
> test2(dexp)
        [,1]       [,2]
r1 0.5838058 -0.5223427
r2 0.5838058 -0.5223427
        [,1]      [,2]
r1 0.5838058 0.3739206
r2 0.5838058 0.3739206
                     x1        x2
r1 0.5838058 -0.5223427 0.3739206
r2 0.5838058 -0.5223427 0.3739206
                     g1        g2
r1 0.5838058 -0.5223427 0.3739206
r2 0.5838058 -0.5223427 0.3739206
> test2(dexp,log=TRUE)
         [,1]     [,2]
r1 -0.5381869 -0.89472
r2 -0.5381869 -0.89472
         [,1]      [,2]
r1 -0.5381869 0.6404881
r2 -0.5381869 0.6404881
                    x1        x2
r1 -0.5381869 -0.89472 0.6404881
r2 -0.5381869 -0.89472 0.6404881
                    g1        g2
r1 -0.5381869 -0.89472 0.6404881
r2 -0.5381869 -0.89472 0.6404881
> test1r(rexp)
        [,1]      [,2]
r1 0.7957275 -2.430519
r2 0.7957275 -2.430519
> 
> test2i(dgeom)
          [,1]        [,2]
r1 0.001044058 -0.02858399
r2 0.001044058 -0.02858399
> test2i(dgeom,log=TRUE)
       [,1]      [,2]
r1 -6.86464 -27.37777
r2 -6.86464 -27.37777
> 
> test2r(rnorm)
            x1        x2
r1 0.774704  1 0.3325331
r2 0.774704  1 0.3325331
> 
> test2r(runif)
                    x1        x2
r1 0.7403373 0.3697434 0.6302566
r2 0.7403373 0.3697434 0.6302566
> 
