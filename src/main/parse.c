/*
 *  pqR : A pretty quick version of R
 *  Copyright (C) 2013, 2014, 2015 by Radford M. Neal
 *
 *  Based on R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995, 1996, 1997  Robert Gentleman and Ross Ihaka
 *  Copyright (C) 1997--2010  The R Development Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define USE_FAST_PROTECT_MACROS
#include "IOStuff.h"		/*-> Defn.h */
#include "Fileio.h"
#include "Parse.h"
#include <R_ext/Print.h>

#if !defined(__STDC_ISO_10646__) && (defined(__APPLE__) || defined(__FreeBSD__))
/* This may not be 100% true (see the comment in rlocales.h),
   but it seems true in normal locales */
# define __STDC_ISO_10646__
#endif


/* --------------------------------------------------------------------------
   PARSING ENTRY POINTS PROVIDED
 
   The following routines parse several expressions and return their
   values in a single expression vector.
 
       SEXP R_ParseVector (SEXP *text, int n, ParseStatus *status, SEXP srcfile)

       SEXP R_ParseStream (int (*getc)(void *), void *getc_arg, int n, 
                           ParseStatus *status, SEXP srcfile);

   The following routine parses a single expression:
 
       SEXP R_Parse1Stream (int (*getc)(void *), void *getc_arg, 
                            ParseStatus *status, SrcRefState *state);

   The R_InitSrcRefState and R_FinalizeSrcRefState will be needed in
   conjunction with this routine, and possibly R_TextForSrcRefState.

   The success of the parse is indicated as follows:
 
 	status = PARSE_NULL       - there was no statement to parse
 		 PARSE_OK	  - complete statement
 		 PARSE_ERROR      - syntax error
 		 PARSE_EOF	  - end of file

   PARSE_NULL and PARSE_EOF are not possible for R_ParseVector and
   R_ParseStream.  

   All the above are declared in Parse.h or R_ext/Parse.h.

   If PARSE_ERROR is returned, the error message and context is in 
   the global variables R_ParseErrorMsg, R_ParseContext, etc., which
   are declared in Defn.h.

   This module also defines the isValidName function, since it needs to 
   know the list of reserved words.
*/


/* --------------------------------------------------------------------------
   GRAMMAR FROM THE OLD BISON VERSION OF THE PARSER, WITHOUT THE ACTIONS

   The parser was previously a bottom-up one, generated by Bison.  It is
   now a top-down one, done by recursive descent, but there are traces
   of the old Bison version in some names and comments.  The grammar
   below is now shown just for (possibly out-of-date) documentation.

   Note that the preedence table given is misleading, since the declared 
   precedence applies only when the grammar is ambiguous. */

#if 0

/* This is the precedence table, low to high */

%left		'?'
%left		LOW WHILE FOR REPEAT
%right		IF
%left		ELSE
%right		LEFT_ASSIGN
%right		EQ_ASSIGN
%left		RIGHT_ASSIGN
%left		'~' TILDE
%left		OR OR2
%left		AND AND2
%left		UNOT NOT
%nonassoc   	GT GE LT LE EQ NE
%left		'+' '-'
%left		'*' '/'
%left		SPECIAL
%left		':'
%left		UMINUS UPLUS
%right		'^'
%left		'$' '@'
%left		NS_GET NS_GET_INT
%nonassoc	'(' '[' LBB

prog	:	END_OF_INPUT			
	|	'\n'				
	|	expr_or_assign '\n'		
	|	expr_or_assign ';'		
	|	error	 			
	;

expr_or_assign  :    expr                     
                |    equal_assign               
                ;

equal_assign    :    expr EQ_ASSIGN expr_or_assign  
                ;

expr	: 	NUM_CONST			
	|	STR_CONST			
	|	NULL_CONST			
	|	SYMBOL				

	|	'{' exprlist '}'		
	|	'(' expr_or_assign ')'		

	|	'-' expr %prec UMINUS		
	|	'+' expr %prec UMINUS		
	|	'!' expr %prec UNOT		
	|	'~' expr %prec TILDE		
	|	'?' expr			

	|	expr ':'  expr			
	|	expr '+'  expr			
	|	expr '-' expr			
	|	expr '*' expr			
	|	expr '/' expr			
	|	expr '^' expr 			
	|	expr SPECIAL expr		
	|	expr '%' expr			
	|	expr '~' expr			
	|	expr '?' expr			
	|	expr LT expr			
	|	expr LE expr			
	|	expr EQ expr			
	|	expr NE expr			
	|	expr GE expr			
	|	expr GT expr			
	|	expr AND expr			
	|	expr OR expr			
	|	expr AND2 expr			
	|	expr OR2 expr			

	|	expr LEFT_ASSIGN expr 		
	|	expr RIGHT_ASSIGN expr 		
	|	FUNCTION '(' formlist ')' cr expr_or_assign %prec LOW
	|	expr '(' sublist ')'		
	|	IF ifcond expr_or_assign 	
	|	IF ifcond expr_or_assign ELSE expr_or_assign	
	|	FOR forcond expr_or_assign %prec FOR 	
	|	WHILE cond expr_or_assign	
	|	REPEAT expr_or_assign		
	|	expr LBB sublist ']' ']'	
	|	expr '[' sublist ']'		
	|	SYMBOL NS_GET SYMBOL		
	|	SYMBOL NS_GET STR_CONST		
	|	STR_CONST NS_GET SYMBOL		
	|	STR_CONST NS_GET STR_CONST	
	|	SYMBOL NS_GET_INT SYMBOL	
	|	SYMBOL NS_GET_INT STR_CONST	
	|	STR_CONST NS_GET_INT SYMBOL	
	|	STR_CONST NS_GET_INT STR_CONST	
	|	expr '$' SYMBOL			
	|	expr '$' STR_CONST		
	|	expr '@' SYMBOL			
	|	expr '@' STR_CONST		
	|	NEXT				
	|	BREAK				
	;


cond	:	'(' expr ')'			
	;

ifcond	:	'(' expr ')'			
	;

forcond :	'(' SYMBOL IN expr ')' 		
	;


exprlist:					
	|	expr_or_assign			
	|	exprlist ';' expr_or_assign	
	|	exprlist ';'			
	|	exprlist '\n' expr_or_assign	
	|	exprlist '\n'			
	;

sublist	:	sub				
	|	sublist cr ',' sub		
	;

sub	:					
	|	expr				
	|	SYMBOL EQ_ASSIGN 		
	|	SYMBOL EQ_ASSIGN expr		
	|	STR_CONST EQ_ASSIGN 		
	|	STR_CONST EQ_ASSIGN expr	
	|	NULL_CONST EQ_ASSIGN 		
	|	NULL_CONST EQ_ASSIGN expr	
	;

formlist:					
	|	SYMBOL				
	|	SYMBOL EQ_ASSIGN expr		
	|	formlist ',' SYMBOL		
	|	formlist ',' SYMBOL EQ_ASSIGN expr 
	;

cr	:	
	;
#endif


/* --------------------------------------------------------------------------
   INTERFACE FROM THE PARSER, TO THE LEXICAL ANALYSER, TO CHARACTER INPUT

   The xxgetc function returns the next character; xxungetc pushes
   a character back to be returned by xxgetc later.

   The xxgetc function gets a character by calling the function pointed 
   to by ps->ptr_getc, which is set to different functions for different
   input sources. 

   The xxgetc function also maintains the lineno, etc. for source
   references in ps->sr, and the context for error reporting in 
   ps->ParseContext (later copied to R_ParseContext). */


/* Codes for token types.  ASCII codes for single characters also act as
   token numbers.  

   Note that '\n' is returned at the end of a line of input text, and
   is treated the same as end of file if the expression could end
   there.  Otherwise, it is skipped as a token, except that
   newline_before_token is set when the following token is returned. */

enum token_type {
  UNUSED=256,   END_OF_INPUT,   ERROR,     STR_CONST,        NUM_CONST,
  SYMBOL,       LEFT_ASSIGN,    EQ_ASSIGN, RIGHT_ASSIGN,     NULL_CONST,
  FUNCTION,     LBB,            FOR,       IN,               IF,
  ELSE,         WHILE,          NEXT,      BREAK,            REPEAT,
  GT,           GE,             LT,        LE,               EQ,
  NE,           AND,            OR,        AND2,             OR2,
  NS_GET,       NS_GET_INT,     EXPT2,     SPECIAL,          COLON_ASSIGN
};

/* Names for tokens with codes >= 256.  These must correspond in order
   with the codes for token types above.  They are used for error messages. */

static const char *const token_name[] = {
  "input",      "end of input", "input",   "string constant","numeric constant",
  "symbol",     "assignment",   "=",       "->",             "'NULL'",
  "'function'", "'[['",         "'for'",   "'in'",           "'if'",
  "'else'",     "'while'",      "'next'",  "'break'",        "'repeat'",
  "'>'",        "'>='",         "'<'",     "'<='",           "'=='",
  "'!='",       "'&'",          "'|'",     "'&&'",           "'||'",
  "'::'",       "':::'",        "**",      "SPECIAL",        "':='"
};

#define NUM_TRANSLATED 7  /* Number above (at front) that are translated */

#if 0  /* These are just here to trigger the internationalization. */
    _("end of input");
    _("input");
    _("string constant");
    _("numeric constant");
    _("symbol");
    _("assignment");
    _("end of line");  /* currently unused */
#endif

/* Another set of names for tokens with codes >= 256.  These ones are used
   for the results of getParseData. */

static const char *const pdata_token_name[] = {
  "INPUT",      "END_OF_INPUT", "ERROR",   "STR_CONST",      "NUM_CONST",
  "SYMBOL",     "LEFT_ASSIGN",  "EQ_ASSIGN", "RIGHT_ASSIGN", "NULL_CONST",
  "FUNCTION",   "LBB",          "FOR",     "IN",             "IF",
  "ELSE",       "WHILE",        "NEXT",    "BREAK",          "REPEAT",
  "GT",         "GE",           "LT",      "LE",             "EQ",
  "NE",         "AND",          "OR",      "AND2",           "OR2",
  "NS_GET",     "NS_GET_INT",   "^",       "SPECIAL",        "COLON_ASSIGN"
};


/* Record of the start and end of part of the source text.  See the
   information in help(srcfile). */

typedef struct
{
  int first_line;
  int first_column;
  int first_byte;

  int last_line;
  int last_column;
  int last_byte;
  
  int first_parsed;
  int last_parsed;
} source_location;


/* Pointer to the complete state of the parser.  The structure pointed
   to is allocated local to the outermost parsing function, then
   referenced by this static global pointer in many routines.  The old
   pointer is saved in the outermost parsing routine and then restored
   at the end, allowing the parser to be called recursively as part of
   getting an input character. */

struct parse_state {

    /* The next token from the input, and asociated variables and functions. */

    int next_token;            /* The next token, as an integer code */
    SEXP next_token_val;       /* The value associated with next_token */
    int newline_before_token;  /* 1 if next token was preceded by '\n' */

    int keep_source;           /* Attach source references to R expressions? */

    source_location token_loc; /* Location data for the lookahead token */
    source_location prev_token_loc;  /*  ... and the one previous to it */

    SrcRefState *sr;           /* Pointer to source reference info */

    /* Context for error report */

    char ParseContext[PARSE_CONTEXT_SIZE];  /* Circular buffer */
    int ParseContextLast;
    int ParseContextLine;

    /* State of character getting and ungetting (see xxgetc below). */

    int (*ptr_getc)(void);     /* Function to call to get a character */

    void *stream_getc_arg;
    int (*stream_getc)(void *);
    TextBuffer *textb_ptr;

#   define PUSHBACK_BUFSIZE 16

    int pushback[PUSHBACK_BUFSIZE];

    int prevlines[PUSHBACK_BUFSIZE];
    int prevcols[PUSHBACK_BUFSIZE];
    int prevbytes[PUSHBACK_BUFSIZE];
    int prevparse[PUSHBACK_BUFSIZE];

    unsigned int npush;
    int prevpos;
};

static struct parse_state *ps; /* currently active parse */

static int get_next_token(void);  /* Update ps->next_token to the next one */

#include <R_ext/rlocale.h>

#ifdef HAVE_LANGINFO_CODESET
# include <langinfo.h>
#endif

static int xxgetc();
static void xxungetc(int);


/* --------------------------------------------------------------------------
   DECLARATIONS AND ROUTINES TO SUPPORT PRODUCTION OF PARSE DATA
 */

#define PDATA_ROWS 8           /* Rows in the parseData matrix */

#define PDATA_FIRST_PARSED 0   /* Indexes for rows in the parseData matrix */
#define PDATA_FIRST_COLUMN 1
#define PDATA_LAST_PARSED  2
#define PDATA_LAST_COLUMN  3
#define PDATA_TERMINAL     4
#define PDATA_TOKEN        5
#define PDATA_ID           6
#define PDATA_PARENT       7

#define PDATA_REC_LEN    5     /* Number of elements in parseData records */

#define PDATA_REC_LINK   0
#define PDATA_REC_IDATA  1
#define PDATA_REC_TOKEN  2
#define PDATA_REC_TEXT   3
#define PDATA_REC_UPLINK 4

#define PDATA_IDATA_VAL(pd,ix) \
    INTEGER (VECTOR_ELT (pd, PDATA_REC_IDATA)) [ix]


/* Routine to be called for each token seen and each expression parsed, 
   that creates a parse data record for it. */

static SEXP start_parseData_record (source_location *start_loc, 
                                    const char *token, const char *text, 
                                    int terminal)
{
    SEXP idat, rec, up;
    int i;

    if (!ps->keep_source) return R_NilValue;

    /* Allocate a record for this syntactic object, and add it to the
       front of the linked list of parse data records. */

    rec = allocVector (VECSXP, PDATA_REC_LEN);
    SET_VECTOR_ELT (rec, PDATA_REC_LINK, ps->sr->ParseData);
    REPROTECT (ps->sr->ParseData = rec, ps->sr->ParseDataProt);

    /* Set the parent of this record to the record of the current 
       containing object.  (But this may be changed later.)  This
       record then becomes the new containing record. */

    up = ps->sr->containing_parse_rec;
    SET_VECTOR_ELT (rec, PDATA_REC_UPLINK, up);
    ps->sr->containing_parse_rec = rec;

    /* Allocate space for the integer portion of the record. */

    idat = allocVector (INTSXP, PDATA_ROWS);

    for (i = 0; i < PDATA_ROWS; i++) 
        INTEGER(idat)[i] = NA_INTEGER;             /* FOR NOW */

    /* Put information in the record.  The last parsed and column fields
       can't be filled in yet, however. */

    SET_VECTOR_ELT (rec, PDATA_REC_IDATA,  idat);
    SET_VECTOR_ELT (rec, PDATA_REC_TOKEN,  mkChar(token));
    SET_VECTOR_ELT (rec, PDATA_REC_TEXT,   mkChar(text));

    INTEGER(idat)[PDATA_FIRST_PARSED] = start_loc->first_parsed;
    INTEGER(idat)[PDATA_FIRST_COLUMN] = start_loc->first_column;
    INTEGER(idat)[PDATA_TERMINAL] = terminal;
    INTEGER(idat)[PDATA_PARENT] = 
      up == R_NilValue ? 0 : PDATA_IDATA_VAL (up, PDATA_ID);

    INTEGER(idat)[PDATA_ID] = ps->sr->next_id;
    ps->sr->next_id += 1;

    return rec;
}

/* Routine to be called to complete a parse data record, once the end 
   location is known. */

static void end_parseData_record (SEXP rec, source_location *end_loc)
{
    if (rec == R_NilValue) return;

    /* Store the end location in the parse data record. */

    PDATA_IDATA_VAL (rec, PDATA_LAST_PARSED) = end_loc->last_parsed;
    PDATA_IDATA_VAL (rec, PDATA_LAST_COLUMN) = end_loc->last_column;

    /* Make the containing record be the one containing this record. */

    ps->sr->containing_parse_rec = 
      VECTOR_ELT (ps->sr->containing_parse_rec, PDATA_REC_UPLINK);
}

static SEXP prev_token_rec (int n)
{
    SEXP rec = ps->sr->ParseData; 

    while (rec != R_NilValue) {
        if (PDATA_IDATA_VAL (rec, PDATA_TERMINAL)) {
            n -= 1;
            if (n == 0) break;
        }
        rec = VECTOR_ELT (rec, PDATA_REC_LINK);
    }

    return rec;
}

static void set_parent (SEXP rec, SEXP parent_rec)
{
    if (rec != R_NilValue) {
        SET_VECTOR_ELT (rec, PDATA_REC_UPLINK, parent_rec);
        PDATA_IDATA_VAL (rec, PDATA_PARENT) 
          = PDATA_IDATA_VAL (parent_rec, PDATA_ID);
    }
}

static void set_token (SEXP rec, char *token)
{
    if (rec != R_NilValue)
        SET_VECTOR_ELT (rec, PDATA_REC_TOKEN, mkChar(token));
}

/* A kludge routine that deletes the second from the latest parse data
   record.  Used to fix up arg lists with keywords, like f(k=x), where
   k initially looks like it could be an expression.  Fiddles IDs too. */

static void delete_second_parseData_record (void)
{
    if (!ps->keep_source) return;

    SEXP rec1 = ps->sr->ParseData;
    if (rec1 == R_NilValue) abort();
    SEXP rec2 = VECTOR_ELT(rec1,PDATA_REC_LINK);
    if (rec2 == R_NilValue) abort();
    SEXP rec3 = VECTOR_ELT(rec2,PDATA_REC_LINK);
    if (rec3 == R_NilValue) abort();

    SET_VECTOR_ELT (rec1, PDATA_REC_LINK, VECTOR_ELT(rec2,PDATA_REC_LINK));

    PDATA_IDATA_VAL (rec1, PDATA_ID) -= 1;
    ps->sr->next_id -= 1;

    set_parent (rec3, ps->sr->containing_parse_rec);
}


/* --------------------------------------------------------------------------
   CHARACTER INPUT ROUTINES
*/

static int xxgetc(void)
{

    int c, oldpos;

    if (ps->npush > 0)
        c = ps->pushback[--(ps->npush)];
    else
        c = ps->ptr_getc();

    oldpos = ps->prevpos;
    ps->prevpos = (ps->prevpos + 1) % PUSHBACK_BUFSIZE;
    ps->prevbytes[ps->prevpos] = ps->sr->xxbyteno;
    ps->prevlines[ps->prevpos] = ps->sr->xxlineno;  
    ps->prevparse[ps->prevpos] = ps->sr->xxparseno;

    /* We only advance the column for the 1st byte in UTF-8, so handle later 
       bytes specially */

    if (0x80 <= (unsigned char) c && (unsigned char) c <= 0xBF 
                                  && known_to_be_utf8) {
    	ps->sr->xxcolno--;   
    	ps->prevcols[ps->prevpos] = ps->prevcols[oldpos];
    } else 
    	ps->prevcols[ps->prevpos] = ps->sr->xxcolno;

    if (c == '\n') {
	ps->sr->xxlineno += 1;
	ps->sr->xxcolno = 0;
    	ps->sr->xxbyteno = 0;
    	ps->sr->xxparseno += 1;
    } else {
        ps->sr->xxcolno += 1;
    	ps->sr->xxbyteno += 1;
    }

    if (c == '\t') ps->sr->xxcolno = ((ps->sr->xxcolno + 7) & ~7);
    	
    if (c == EOF)
	return R_EOF;
    
    ps->ParseContextLast = (ps->ParseContextLast + 1) % PARSE_CONTEXT_SIZE;
    ps->ParseContext[ps->ParseContextLast] = c;
    ps->ParseContextLine = ps->sr->xxlineno;    

    return c;
}

static void xxungetc(int c)
{
    /* This assumes that c was the result of xxgetc; if not, some edits will 
       be needed */

    ps->sr->xxlineno = ps->prevlines[ps->prevpos];
    ps->sr->xxbyteno = ps->prevbytes[ps->prevpos];
    ps->sr->xxcolno  = ps->prevcols[ps->prevpos];
    ps->sr->xxparseno = ps->prevparse[ps->prevpos];
    
    ps->prevpos = (ps->prevpos + PUSHBACK_BUFSIZE - 1) % PUSHBACK_BUFSIZE;

    ps->ParseContextLine = ps->sr->xxlineno;

    ps->ParseContext[ps->ParseContextLast] = '\0';
    /* precaution as to how % is implemented for < 0 numbers */
    ps->ParseContextLast 
      = (ps->ParseContextLast + PARSE_CONTEXT_SIZE - 1) % PARSE_CONTEXT_SIZE;
    if (ps->npush >= PUSHBACK_BUFSIZE) abort();
    ps->pushback[ps->npush++] = c;
}


/* --------------------------------------------------------------------------
   SOURCE REFERENCE ROUTINES
*/

static SEXP makeSrcref(source_location *lloc, SEXP srcfile)
{
    SEXP val;

    PROTECT(val = allocVector(INTSXP, 8));
    INTEGER(val)[0] = lloc->first_line;
    INTEGER(val)[1] = lloc->first_byte;
    INTEGER(val)[2] = lloc->last_line;
    INTEGER(val)[3] = lloc->last_byte;
    INTEGER(val)[4] = lloc->first_column;
    INTEGER(val)[5] = lloc->last_column;
    INTEGER(val)[6] = lloc->first_parsed;
    INTEGER(val)[7] = lloc->last_parsed;
    setAttrib(val, R_SrcfileSymbol, srcfile);
    setAttrib(val, R_ClassSymbol, mkString("srcref"));
    UNPROTECT(1);
    return val;
}

static void attachSrcrefs(SEXP val, SEXP t)
{
    SEXP srval;
    int n;

    PROTECT(val);
    PROTECT(srval = allocVector(VECSXP, length(t)));

    for (n = 0 ; n < LENGTH(srval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(srval, n, CAR(t));
    setAttrib(val, R_SrcrefSymbol, srval);
    setAttrib(val, R_SrcfileSymbol, ps->sr->SrcFile);

    source_location wholeFile;
    wholeFile.first_line = 1;
    wholeFile.first_byte = 0;
    wholeFile.first_column = 0;
    wholeFile.last_line = ps->sr->xxlineno;
    wholeFile.last_byte = ps->sr->xxbyteno;
    wholeFile.last_column = ps->sr->xxcolno;
    wholeFile.first_parsed = 1;
    wholeFile.last_parsed = ps->sr->xxparseno;
    setAttrib(val, R_WholeSrcrefSymbol, 
                   makeSrcref(&wholeFile, ps->sr->SrcFile));

    UNPROTECT(2);

    ps->sr->didAttach = TRUE;
}

void R_InitSrcRefState (SrcRefState *state, int keepSource)
{
    state->keepSrcRefs = keepSource;
    state->didAttach = FALSE;

    if (keepSource) {
        PROTECT_WITH_INDEX (state->SrcFile =
                             NewEnvironment(R_NilValue, R_NilValue, R_EmptyEnv),
                            &state->SrcFileProt);
        PROTECT_WITH_INDEX (state->Original = state->SrcFile, 
                            &state->OriginalProt);
    }
    else {
        PROTECT_WITH_INDEX (state->SrcFile = R_NilValue, &state->SrcFileProt);
        PROTECT_WITH_INDEX (state->Original = R_NilValue, &state->OriginalProt);
    }

    state->xxlineno = 1;
    state->xxcolno = 0;
    state->xxbyteno = 0;
    state->xxparseno = 1;

    PROTECT_WITH_INDEX (state->ParseData = R_NilValue, &state->ParseDataProt);
    state->containing_parse_rec = R_NilValue;
    state->next_id = 1;
}

void R_TextForSrcRefState (SrcRefState *state, const char *text)
{
    if (state->didAttach) {
        SEXP filename_install = install("filename");  /* protected by the */
        SEXP lines_install = install("lines");        /*   symbol table   */
        SEXP class;
        set_var_in_frame (filename_install, ScalarString(mkChar("")),
                          state->Original, TRUE, 3);
        set_var_in_frame (lines_install, ScalarString(mkChar(text)),
                          state->Original, TRUE, 3);

        PROTECT(class = allocVector(STRSXP, 2));
        SET_STRING_ELT(class, 0, mkChar("srcfilecopy"));
        SET_STRING_ELT(class, 1, mkChar("srcfile"));
        setAttrib(state->Original, R_ClassSymbol, class);
        UNPROTECT(1);
    }
}

void R_FinalizeSrcRefState (SrcRefState *state)
{
    /* Convert parse data to final form. */

    int pdlen;
    SEXP p;

    pdlen = 0;
    for (p = state->ParseData; p!=R_NilValue; p = VECTOR_ELT(p,PDATA_REC_LINK))
        pdlen += 1;

    if (pdlen > 0 && isEnvironment(state->SrcFile)) {

        SEXP dims, mat, tokens, text, pdat, idat;
        int i, j, k;

        PROTECT (dims = allocVector (INTSXP, 2));
        INTEGER(dims)[0] = PDATA_ROWS;
        INTEGER(dims)[1] = pdlen;

        PROTECT (mat = allocVector (INTSXP, PDATA_ROWS*pdlen));

        PROTECT (tokens = allocVector (STRSXP, pdlen));
        PROTECT (text = allocVector (STRSXP, pdlen));

        pdat = state->ParseData;
        k = 0;
        for (i = 0; i < pdlen; i++) {
            idat = VECTOR_ELT(pdat,PDATA_REC_IDATA);
            for (j = 0; j < PDATA_ROWS; j++)
                INTEGER(mat)[k++] = INTEGER(idat)[j];
            SET_STRING_ELT (tokens, i, VECTOR_ELT(pdat,PDATA_REC_TOKEN));
            SET_STRING_ELT (text, i, VECTOR_ELT(pdat,PDATA_REC_TEXT));
            pdat = VECTOR_ELT(pdat,PDATA_REC_LINK);
        }

        setAttrib (mat, install("dim"), dims);
        setAttrib (mat, install("tokens"), tokens);
        setAttrib (mat, install("text"), text);
        setAttrib (mat, R_ClassSymbol, mkString("parseData"));

        set_var_in_frame (install("parseData"), mat, state->SrcFile, TRUE, 3);

        UNPROTECT(4); /* text, tokens, mat, dims */
    }

    /* We could just do an UNPROTECT(3), but this might detect some bugs... */

    UNPROTECT(1);
    if (R_PPStackTop != state->ParseDataProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->OriginalProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->SrcFileProt) abort();

    state->containing_parse_rec = R_NilValue;  /* just in case... */
    state->ParseData = R_NilValue;
    state->Original = R_NilValue;
    state->SrcFile = R_NilValue;
}


/* --------------------------------------------------------------------------
   VARIABLES, MACROS, AND FUNCTIONS SUPPORTING THE PARSER
*/

/* Begin a recursive-descent parsing routine.  Sets up for PROTECT_N. 
   Sets bgn_token_rec to the parse data record of the most recently
   obtained token (or to R_NilValue is source isn't kept). */

#define BGN_PARSE_FUN \
    NEXT_TOKEN;  /* so location and bgn_token_rec will be correct */ \
    SEXP bgn_token_rec = prev_token_rec(1); \
    int nprotect = 0;

/* End a recursive-descent parsing routine.  Unprotects everything that
   was protected with PROTECT_N.  Allows for exitting with NULL result
   on an error. */

#define END_PARSE_FUN \
  end: \
    UNPROTECT(nprotect); \
    goto finish; \
  error: \
    UNPROTECT(nprotect); \
    return NULL; \
  finish:


/* Parse a sub-expression (or other construct), with the call given as
   its argument.  Protects the result, which will normally be assigned
   to a local variable (in the argument).  If the sub-expression parse
   produced an error, this parse routine is exitted as well. */

#define PARSE_SUB(w) \
    do { \
        SEXP _sub_ = (w); \
        if (_sub_ == NULL) goto error; \
        PROTECT_N(_sub_); \
    } while (0)


/* Produce an error message and exit parsing (up to the top level). */

#define PARSE_ERROR_MSG(s) \
    do { \
        error_msg(s); \
        goto error; \
    } while (0)

static void error_msg(const char *s)
{
    static char const unexpected[] = "syntax error, unexpected ";

    R_ParseError     = ps->token_loc.first_line;
    R_ParseErrorCol  = ps->token_loc.first_column;
    R_ParseErrorFile = ps->sr->SrcFile;

    if (strcmp(s,unexpected) == 0) {
        if (ps->next_token < 256) {
            char t[4] = { '\'', ps->next_token, '\'', 0 };
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, t);
        }
        else if (ps->next_token-256 < NUM_TRANSLATED)
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, 
                           _(token_name[ps->next_token-256]));
        else
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, 
                           token_name[ps->next_token-256]);
    }
    else
        copy_1_string(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s);

    R_ParseErrorMsg [(sizeof R_ParseErrorMsg) - 1] = 0; /* just in case */
}


/* Produce an error message saying the current token is unexpected, and
   exit to top level.  The token name is filled in by error_msg, based
   on the current value of next_token. */

#define PARSE_UNEXPECTED() PARSE_ERROR_MSG("syntax error, unexpected ");


/* Say the current is unexpected unless it is equal to tk. */

#define EXPECT(tk) \
    do { \
        if (ps->next_token != (tk)) \
            PARSE_UNEXPECTED(); \
        get_next_token(); \
    } while (0)


/* Protect a SEXP used in a parse routine from garbage collection. */

#define PROTECT_N(w) (nprotect++, PROTECT(w))


/* Look at the next token, which will usually already be in next_token.
   However, if next_token is '\n', advance to the next token first. */

#define NEXT_TOKEN \
  (ps->next_token == '\n' ? get_next_token_not_newline() : ps->next_token) 

static int get_next_token_not_newline(void)
{
    do { 
        get_next_token(); 
    } while (ps->next_token == '\n');

    ps->newline_before_token = 1;

    return ps->next_token;
}


/* Get the SEXP value associated with next_token, protecting it. */

#define TOKEN_VALUE() (PROTECT_N(ps->next_token_val))


/* Check whether the current expression is ended by a newline, based on
   the 'flags' and 'newline_before_token' variables. */

#define NL_END ((flags & END_ON_NL) && ps->newline_before_token)


/* Save the start location of next_token as the start of a region of
   the source text. */

static void start_location (source_location *loc)
{
    loc->first_line   = loc->last_line   = ps->token_loc.first_line;
    loc->first_column = loc->last_column = ps->token_loc.first_column;
    loc->first_byte   = loc->last_byte   = ps->token_loc.first_byte;
    loc->first_parsed = loc->last_parsed = ps->token_loc.first_parsed;
}


/* Save the end location of the previous token as the end of a region
   of source text. */

static void end_location (source_location *loc)
{
    loc->last_line   = ps->prev_token_loc.last_line;
    loc->last_column = ps->prev_token_loc.last_column;
    loc->last_byte   = ps->prev_token_loc.last_byte;
    loc->last_parsed = ps->prev_token_loc.last_parsed;
}


/* Tables of operator precedence.  The lower two bits are 1 for binary
   operators that are left associative, 2 for binary operators that are
   right associative, and 0 for relational operators, unary operators,
   and miscellaneous operators.  This is expressed in the NON_ASSOC, 
   LEFT_ASSOC, and RIGHT_ASSOC macros in Parse.h. */

static struct { SEXP *sym_ptr; int prec; } unary_prec_tbl[] =
{
    { &R_AddSymbol,               /* +   */ 0xc8 },
    { &R_SubSymbol,               /* -   */ 0xc8 },
    { &R_NotSymbol,               /* !   */ 0x78 },
    { &R_TildeSymbol,             /* ~   */ 0x58 },
    { &R_QuerySymbol,             /* ?   */ 0x28 },
    { 0, 0 }
};

static struct { SEXP *sym_ptr; int prec; } binary_prec_tbl[] =
{
    { &R_DoubleColonSymbol,       /* ::  */ 0xf0 },
    { &R_TripleColonSymbol,       /* ::: */ 0xf0 },
    { &R_ExptSymbol,              /* ^   */ 0xd2 },
    { &R_Expt2Symbol,             /* **  */ 0xd2 },
    { &R_ColonSymbol,             /* :   */ 0xc1 },
#   define SPECIAL_PREC           /* %x% */ 0xb1
    { &R_MulSymbol,               /* *   */ 0xa1 },
    { &R_DivSymbol,               /* /   */ 0xa1 },
    { &R_AddSymbol,               /* +   */ 0x91 },
    { &R_SubSymbol,               /* -   */ 0x91 },
    { &R_EqSymbol,                /* ==  */ 0x80 },
    { &R_NeSymbol,                /* !=  */ 0x80 },
    { &R_LtSymbol,                /* <   */ 0x80 },
    { &R_LeSymbol,                /* <=  */ 0x80 },
    { &R_GeSymbol,                /* >=  */ 0x80 },
    { &R_GtSymbol,                /* >   */ 0x80 },
    { &R_AndSymbol,               /* &   */ 0x71 },
    { &R_And2Symbol,              /* &&  */ 0x71 },
    { &R_OrSymbol,                /* |   */ 0x61 },
    { &R_Or2Symbol,               /* ||  */ 0x61 },
    { &R_TildeSymbol,             /* ~   */ 0x51 },
    { &R_LocalRightAssignSymbol,  /* ->  */ 0x41 },
    { &R_GlobalRightAssignSymbol, /* ->> */ 0x41 },
    { &R_LocalAssignSymbol,       /* <-  */ 0x32 },
    { &R_GlobalAssignSymbol,      /* <<- */ 0x32 },
    { &R_ColonAssignSymbol,       /* :=  */ 0x32 },
    { &R_QuerySymbol,             /* ?   */ 0x21 },
    { &R_EqAssignSymbol,          /* =   */ 0x12 },
    { 0, 0 }
#   define EQASSIGN_PREC 0x12
};

static struct { SEXP *sym_ptr; int prec; } misc_prec_tbl[] =
{
    { &R_BracketSymbol,           /* [   */ 0xe8 },
    { &R_Bracket2Symbol,          /* [[  */ 0xe8 },
    { &R_DollarSymbol,            /* $   */ 0xe8 },
    { &R_AtSymbol,                /* @   */ 0xe8 },

    { &R_FunctionSymbol,          /*     */ 0x08 },
    { &R_IfSymbol,                /*     */ 0x08 },
    { &R_WhileSymbol,             /*     */ 0x08 },
    { &R_RepeatSymbol,            /*     */ 0x08 },

    { 0, 0 }
};

/* Return the unary precedence of an operator symbol, or 0 if the 
   symbol is not a unary operator. */

attribute_hidden int unary_prec (SEXP sym)
{
    int i;

    for (i = 0; unary_prec_tbl[i].prec != 0; i++) {
        if (sym == *unary_prec_tbl[i].sym_ptr)
            return unary_prec_tbl[i].prec;
    }

    return 0;
}

/* Return the binary precedence of an operator symbol, or 0 if the 
   symbol is not a binary operator. */

attribute_hidden int binary_prec (SEXP sym)
{
    int i;

    for (i = 0; binary_prec_tbl[i].prec != 0; i++) {
        if (sym == *binary_prec_tbl[i].sym_ptr)
            return binary_prec_tbl[i].prec;
    }

    if (TYPEOF(sym) == SYMSXP) {
        const char *s = CHAR(PRINTNAME(sym));
        if (s[0] == '%') {
            for (i = 1; s[i] != 0; i++) {
               if (s[i] == '%')
                   return s[i+1] == 0 ? SPECIAL_PREC : 0;
            }
        }
    }

    return 0;
}

/* Return the precedence of a miscellaneous operator symbol, or 0 if the 
   symbol is not a miscellaneous operator. */

attribute_hidden int misc_prec (SEXP sym)
{
    int i;

    for (i = 0; misc_prec_tbl[i].prec != 0; i++) {
        if (sym == *misc_prec_tbl[i].sym_ptr)
            return misc_prec_tbl[i].prec;
    }

    return 0;
}
   

/* Return 0 if NEXT_TOKEN is not a unary operator, and otherwise
   the precedence of the unary operator. */

static int unary_op(void)
{
    SEXP sym;
    int i;

    /* Operators must be special tokens, not symbols like `+`. */

    if (NEXT_TOKEN == SYMBOL)
        return 0;

    /* A symbol corresponding to an operator will be in next_token_val.
       We don't use TOKEN_VALUE below, since we don't want a PROTECT. */

    sym = ps->next_token_val;
    if (TYPEOF(sym) != SYMSXP)
        return 0;

    /* Return the unary precedence of the symbol, or 0 if not a unary op. */

    return unary_prec (sym);
}

/* Return 0 if NEXT_TOKEN is not a binary operator, and otherwise
   the precedence of the binary operator. */

static int binary_op(void)
{
    SEXP sym;

    /* The special binary operators of the form %xxx% are handled specially
       here (though they could instead be passed on to binary_prec). */

    if (NEXT_TOKEN == SPECIAL)
        return SPECIAL_PREC;

    /* Operators must be special tokens, not symbols like `+`. */

    if (NEXT_TOKEN == SYMBOL)
        return 0;

    /* A symbol corresponding to an operator will be in next_token_val.
       We don't use TOKEN_VALUE below, since we don't want a PROTECT. */

    sym = ps->next_token_val;
    if (TYPEOF(sym) != SYMSXP)
        return 0;

    /* Return the binary precedence of the symbol, or 0 if not a binary op. */

    return binary_prec (sym);
}


/* Macros to create language pairlists in which the last CONS cell may
   be a shared constant.  Note that unlike lang2, lang3, and lang4,
   the arguments must be protected by the caller. */

#define LANG2(y,z) LCONS((y),MaybeConstList1(z))
#define LANG3(x,y,z) LCONS((x),CONS((y),MaybeConstList1(z)))
#define LANG4(w,x,y,z) LCONS((w),CONS((x),CONS((y),MaybeConstList1(z))))



/* --------------------------------------------------------------------------
   THE RECURSIVE DESCENT PARSER

   Each parse routine takes an int flags argument, whose bits have
   the meanings defined below.  

   The parse_expr routine also has a 'paren' argument for controlling
   how parentheses are handled.  If 'paren' is NULL, it is ignored,
   and no check regarding parentheses is done.  If 'paren' is not
   NULL, the int that it points to is set to 0 if the expression is
   not a parenthesized expression, or if the expression inside the
   parentheses is not one with a unary, binary, or relational
   operator.  If the expression is a parenthesized unary, binary, or
   relational operator, *paren is set to the precedence of the
   operator.  This allows the caller to decide whether to remove the
   parentheses if they are necessary (and hence will be re-inserted
   when the expression is deparsed).

   The parse routines return the object parsed, or NULL if there was an
   error (or errors may cause exit out of the whole parser with a call
   of "error").

   Parsing routines are called with next_token already set to the first
   token of the construct they parse, and return with next_token set to
   the token after the construct they parsed.  Note, however, that this
   token may be '\n', which acts as a "soft" end-of-file that is replaced
   by another token if the token is accessed via NEXT_TOKEN rather than
   next_token. 

   Source references are attached if keep_source is non-zero. */

static SEXP parse_expr (int prec, int flags, int *paren);


/* Bits in the flags word passed to parsing routines. */

#define KEEP_PARENS (1<<0)  /* Keep parens in this or inner expressions */
#define END_ON_NL   (1<<1)  /* End expression when newline seen */
#define NO_PEEKING  (1<<2)  /* Don't look ahead for ELSE after newline
                               (only relevant when END_ON_NL set) */

/* Parse the formals list of a function definiton. */

static SEXP parse_formlist (int flags)
{
    BGN_PARSE_FUN;
    SEXP res;

    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);

    res = R_NilValue;
    if (NEXT_TOKEN != ')') {
        SEXP last;
        res = PROTECT_N (CONS(R_MissingArg,R_NilValue));
        last = res;
        for (;;) {
            SEXP tag, f;
            if (NEXT_TOKEN != SYMBOL)
                PARSE_UNEXPECTED();
            set_token (prev_token_rec(1), "SYMBOL_FORMALS");
            tag = TOKEN_VALUE();
            for (f = res; f != R_NilValue; f = CDR(f)) {
                if (TAG(f) == tag) {
                    source_location loc;
                    start_location(&loc);
                    error(_("Repeated formal argument '%s' on line %d"), 
                            CHAR(PRINTNAME(tag)), loc.first_line);
                }
            }
            SET_TAG (last, tag);
            get_next_token();
            if (NEXT_TOKEN == EQ_ASSIGN) {
                SEXP def;
                set_token (prev_token_rec(1), "EQ_FORMALS");
                get_next_token();
                PARSE_SUB(def = parse_expr (EQASSIGN_PREC, subflags, NULL));
                SETCAR (last, def);
            }
            if (NEXT_TOKEN != ',')
                break;
            get_next_token();
            SETCDR (last, CONS(R_MissingArg,R_NilValue));
            last = CDR(last);
        }
    }

    END_PARSE_FUN;
    return res;
}


/* Parse a list of subscripts or of function arguments.  An attempt is 
   made to make the last part of the list be a constant object.  Note
   that NULL is allowed as a tag (converted to `NULL`), presumably for 
   compatibility, though it's not allowed for a formal name.  Strings
   are also allowed for tags, though again they aren't for formal names. */

static SEXP parse_sublist (int flags)
{
    BGN_PARSE_FUN;
    SEXP res, last, last2;

    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);

    res = R_NilValue;
    if (NEXT_TOKEN != ')') { /* check only ')', not ']':  [] has missing arg */
        SEXP next;
        for (;;) {
            SEXP arg;
            if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' || NEXT_TOKEN == ']')
                next = MaybeConstList1(R_MissingArg);
            else {
                PARSE_SUB(arg = parse_expr (EQASSIGN_PREC, subflags, NULL));
                if (NEXT_TOKEN == EQ_ASSIGN) {
                    SEXP tag, val;
                    set_token (prev_token_rec(1), "EQ_SUB");
                    if (TYPEOF(arg) == SYMSXP) {
                        tag = arg;
                        set_token (prev_token_rec(2), "SYMBOL_SUB");
                    }
                    else if (TYPEOF(arg) == STRSXP)
                        tag = install (translateChar (STRING_ELT(arg,0)));
                    else if (arg == R_NilValue)
                        tag = install("NULL");
                    else
                        PARSE_UNEXPECTED();
                    delete_second_parseData_record();
                    get_next_token();
                    if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' 
                                          || NEXT_TOKEN == ']')
                        val = R_MissingArg;
                    else
                        PARSE_SUB(val = parse_expr (EQASSIGN_PREC, subflags,
                                                    NULL));
                    next = cons_with_tag(val,R_NilValue,tag);
                }
                else {
                    next = MaybeConstList1(arg);
                }
            }
            if (res == R_NilValue) {
                res = PROTECT_N (next);
                last = res;
                last2 = R_NilValue;
            }
            else {
                if (IS_CONSTANT(last)) {
                    last = cons_with_tag(CAR(last),CDR(last),TAG(last));
                    if (last2 == R_NilValue)
                        res = PROTECT_N (last);
                    else
                        SETCDR(last2,last);
                }
                SETCDR(last,next);
                last2 = last;
                last = next;
            }
            if (NEXT_TOKEN != ',')
                break;
            get_next_token();
        }
    }

    END_PARSE_FUN;
    return res;
}


/* Parse an expression in which any non-enclosed operator has precedence 
   greater than prec.  An attempt is made to make the last operand of an
   operator be a constant object. */

static SEXP parse_expr (int prec, int flags, int *paren)
{
    BGN_PARSE_FUN;

    SEXP outer_rec, rec, res, right, op;
    int op_prec, next_op_prec;
    source_location begin_loc, loc;

    int keep_parens = flags & KEEP_PARENS;
    int subflags = flags &  ~ (END_ON_NL | NO_PEEKING);
    int par = 0;  /* paren precedence indicator - initially not parenthesized */

    start_location(&begin_loc);
    outer_rec = start_parseData_record(&begin_loc,"expr","",FALSE);
    set_parent (bgn_token_rec, outer_rec);

    /* Unary operators. */

    if (op_prec = unary_op()) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_expr (op_prec, 
                           op == R_TildeSymbol ? flags|KEEP_PARENS : flags,
                           &par));
        if (!keep_parens && par != 0 && par < op_prec)
            res = CADR(res);  /* get rid of parens */
        res = PROTECT_N (LANG2 (op, res));
        par = 0;  /* indicate not a parenthesized expression */
    }

    /* Symbols, string constants, and namespace references built from
       one or the other or both of these. */

    else if (NEXT_TOKEN == SYMBOL || NEXT_TOKEN == STR_CONST) {
        SEXP op, sym;
        res = TOKEN_VALUE();
        get_next_token();
        if (!NL_END && (NEXT_TOKEN == NS_GET || NEXT_TOKEN == NS_GET_INT)) {
            op = TOKEN_VALUE();
            set_token (prev_token_rec(2), "SYMBOL_PACKAGE");
            get_next_token();
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = PROTECT_N (LANG3 (op, res, sym));
            get_next_token();
        }
    }

    /* Numeric, logical, and NULL constants. */

    else if (NEXT_TOKEN == NUM_CONST || NEXT_TOKEN == NULL_CONST) {
        res = TOKEN_VALUE();
        get_next_token();
    }

    /* Paren expressions.  Sets 'par'. */

    else if (NEXT_TOKEN == '(') {
        SEXP op;
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_expr (0, subflags, NULL));
        if (TYPEOF(res) == LANGSXP) {
            int nargs = length(CDR(res));
            if (par == 0 && nargs == 1) par = unary_prec(CAR(res));
            if (par == 0 && nargs == 2) par = binary_prec(CAR(res));
            if (par == 0)               par = misc_prec(CAR(res));
        }
        res = PROTECT_N (LANG2 (op, res));
        EXPECT(')');
    }

    /* Curly expressions. */

    else if (NEXT_TOKEN == '{') {
        SEXP next, last, op, refs, last_ref;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS(op,R_NilValue));
        start_location(&loc);
        get_next_token();
        end_location(&loc);
        if (ps->keep_source) {
            PROTECT_N (refs = CONS (makeSrcref(&loc,ps->sr->SrcFile),
                                    R_NilValue));
            last_ref = refs;
        }
        last = res;
        for (;;) {
            while (NEXT_TOKEN == ';')
                get_next_token();
            if (NEXT_TOKEN == '}')
                break;
            start_location(&loc);
            PARSE_SUB (next = parse_expr (0, subflags | END_ON_NL, NULL));
            end_location(&loc);
            if (ps->keep_source) {
                SETCDR (last_ref, CONS (makeSrcref(&loc,ps->sr->SrcFile),
                                        R_NilValue));
                last_ref = CDR(last_ref);
            }
            SETCDR (last, CONS(next,R_NilValue));
            last = CDR(last);
            if (!ps->newline_before_token && NEXT_TOKEN != ';' 
                                          && NEXT_TOKEN != '}')
                PARSE_UNEXPECTED();
        }
        if (ps->keep_source) {
            attachSrcrefs(res,refs);
        }
        get_next_token();
    }

    /* Function closures. */

    else if (NEXT_TOKEN == FUNCTION) {
        SEXP op, args, body, srcref;
        start_location(&loc);
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(args = parse_formlist (flags));
        EXPECT(')');
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        end_location(&loc);
        if (ps->keep_source) {
            srcref = makeSrcref(&loc, ps->sr->SrcFile);
            ps->sr->didAttach = TRUE;
        } 
        else
            srcref = R_NilValue;
        res = PROTECT_N (lang4 (op, args, body, srcref));
    }

    /* Repeat statements. */

    else if (NEXT_TOKEN == REPEAT) {
        SEXP op, body;
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = PROTECT_N (lang2 (op, body));
    }

    /* While statements. */

    else if (NEXT_TOKEN == WHILE) {
        SEXP op, cond, body;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(cond = parse_expr (EQASSIGN_PREC, subflags, NULL));
        EXPECT(')');
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = PROTECT_N (lang3 (op, cond, body));
    }

    /* If statements. */

    else if (NEXT_TOKEN == IF) {

        SEXP op, cond, true_stmt, false_stmt;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(cond = parse_expr (EQASSIGN_PREC, subflags, NULL));
        EXPECT(')');
        PARSE_SUB(true_stmt = parse_expr(0, flags, NULL));

        if ( ! (NL_END && (flags & NO_PEEKING)) && NEXT_TOKEN == ELSE) {
            get_next_token();
            PARSE_SUB(false_stmt = parse_expr (0, flags, NULL));
            res = PROTECT_N (LANG4 (op, cond, true_stmt, false_stmt));
        }
        else
            res = PROTECT_N (LANG3 (op, cond, true_stmt));
    }

    /* For statements. */

    else if (NEXT_TOKEN == FOR) {
        SEXP op, sym, vec, body;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        if (NEXT_TOKEN != SYMBOL)
            PARSE_UNEXPECTED();
        sym = TOKEN_VALUE();
        get_next_token();
        EXPECT(IN);
        PARSE_SUB(vec = parse_expr (EQASSIGN_PREC, subflags, NULL));
        EXPECT(')');
        PARSE_SUB(body = parse_expr (0, flags, NULL));
        res = PROTECT_N (lang4 (op, sym, vec, body));
    }

    /* Next and break statements. */

    else if (NEXT_TOKEN == NEXT || NEXT_TOKEN == BREAK) {
        SEXP op;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS (op, R_NilValue));
        get_next_token();
    }

    else
        PARSE_UNEXPECTED();

    /* Now handle any postfix parts.  
 
       We first see if there will be any such parts, and if so see if
       necessary parentheses preceded them - if so, the parentheses
       can be eliminated, unless the KEEP_PARENS flag is set.

       Then we loop over all the postfix parts. */

#   define POSTFIX_TOKEN() (NEXT_TOKEN == '(' || NEXT_TOKEN == '[' || \
                            NEXT_TOKEN == LBB || NEXT_TOKEN == '$' || \
                            NEXT_TOKEN == '@')

    if (!NL_END && par != 0 && POSTFIX_TOKEN()) {

        /* Note:  all the postfix operators act the same as [. */

        if (!keep_parens && par < misc_prec(R_BracketSymbol))
            res = CADR(res);  /* get rid of parens */

        par = 0;  /* indicate that this is not a parenthesized expression */
    }

    while (!NL_END && POSTFIX_TOKEN()) {

        rec = start_parseData_record(&begin_loc,"expr","",FALSE);
        set_parent (bgn_token_rec, rec);
        end_location(&loc);
        end_parseData_record(rec,&loc);
        set_parent (prev_token_rec(1), outer_rec);

        /* Function call. */

        if (NEXT_TOKEN == '(') {
            SEXP subs;
            if (TYPEOF(res) == SYMSXP || TYPEOF(res) == LANGSXP &&
                                          (CAR(res) == R_DoubleColonSymbol || 
                                           CAR(res) == R_TripleColonSymbol)) {
                set_token (prev_token_rec(2), "SYMBOL_FUNCTION_CALL");
            }
            get_next_token();
            PARSE_SUB(subs = parse_sublist(flags));
            if (isString(res))
                res = installChar(STRING_ELT(res,0));
            res = PROTECT_N (LCONS(res,subs));
            EXPECT(')');
        }

        /* Subscripting with [. */

        else if (NEXT_TOKEN == '[') {
            SEXP op, subs;
            op = TOKEN_VALUE();
            get_next_token();
            PARSE_SUB(subs = parse_sublist (flags));
            res = PROTECT_N (LCONS (op, CONS (res, subs)));
            EXPECT(']');
        }

        /* Subscripting with [[.  Note that it may be terminated with ] ]. */

        else if (NEXT_TOKEN == LBB) {
            SEXP op, subs;
            op = TOKEN_VALUE();
            get_next_token();
            PARSE_SUB(subs = parse_sublist (flags));
            res = PROTECT_N (LCONS (op, CONS (res, subs)));
            EXPECT(']');
            EXPECT(']');
        }

        /* Subsetting with $ or @. */

        else if (NEXT_TOKEN == '$' || NEXT_TOKEN == '@') {
            SEXP op, sym;
            op = TOKEN_VALUE();
            get_next_token();
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = PROTECT_N (LANG3 (op, res, sym));
            get_next_token();
        }

        else
            abort();
    }

    /* Now handle binary operators following any of the above. */

    int last_prec = 0;

    while (!NL_END) {

        op_prec = binary_op();

        if (op_prec <= prec || op_prec == last_prec)
            break;

        rec = start_parseData_record(&begin_loc,"expr","",FALSE);
        set_parent (bgn_token_rec, rec);
        end_location(&loc);
        end_parseData_record(rec,&loc);
        set_parent (prev_token_rec(1), outer_rec);

        if (!keep_parens && par != 0 
               && (par < op_prec || par == op_prec && !LEFT_ASSOC(op_prec)))
            res = CADR(res);  /* get rid of parens */

        op = TOKEN_VALUE();
        get_next_token();

        if (LEFT_ASSOC(op_prec)) {
            for (;;) {
                PARSE_SUB(right = parse_expr (op_prec, 
                            op == R_TildeSymbol ? flags|KEEP_PARENS : flags,
                            &par));
                if (!keep_parens && par != 0 && par <= op_prec)
                    right = CADR(right);  /* get rid of parens */
                res = PROTECT_N (LANG3 (op, res, right));
                if (NL_END || binary_op() != op_prec) 
                    break;
                op = TOKEN_VALUE();
                get_next_token();
            }
        }
        else if (RIGHT_ASSOC(op_prec)) {
            PARSE_SUB(right = parse_expr (op_prec-1, flags, &par));
            if ( ! (flags & KEEP_PARENS) && par != 0 && par < op_prec)
                right = CADR(right);  /* get rid of parens */
            res = PROTECT_N (LANG3 (op, res, right));
        }
        else { /* NON_ASSOC */
            PARSE_SUB(right = parse_expr (op_prec, flags, &par));
            if (!keep_parens && par != 0 && par <= op_prec)
                right = CADR(right);  /* get rid of parens */
            res = PROTECT_N (LANG3 (op, res, right));
        }

        last_prec = op_prec;

        par = 0;  /* indicate that this is not a parenthesized expression */
    }

    if (paren != NULL) *paren = par;

    end_location(&loc);
    end_parseData_record(outer_rec,&loc);
    if (ps->next_token != '\n' && ps->next_token != END_OF_INPUT)
        set_parent (prev_token_rec(1), ps->sr->containing_parse_rec);
    END_PARSE_FUN;
    return res;
}


/* Top level parse function, parsing an expression (including assignment
   with '=') that is followed by ';', newline, or end of file. */

static SEXP parse_prog (int flags)
{
    BGN_PARSE_FUN;
    SEXP res;

    PARSE_SUB (res = parse_expr (0, flags, NULL));
       
    if (!ps->newline_before_token && NEXT_TOKEN != ';')
        PARSE_UNEXPECTED();

    END_PARSE_FUN;
    return res;
}

/* -------------------------------------------------------------------------- */

/* R_Parse1 is a glue function between the recursive descent parsing routines
   and the parsing entry points.  It sets R_CurrentExpr to the expresion
   parsed (as with the old parsing routines), but it probably shouldn't. 

   The keep_source variable should be set before calling this function. */

static SEXP R_Parse1(ParseStatus *status, source_location *loc)
{
    int flags;
    SEXP keepp;
    SEXP res;

    flags = END_ON_NL | NO_PEEKING;
    keepp = GetOption1(install("keep.parens"));
    if (TYPEOF(keepp) == LGLSXP && LOGICAL(keepp)[0] == 1)
        flags |= KEEP_PARENS;

    if (!get_next_token()) {
        *status = PARSE_EOF;
        return R_CurrentExpr = R_NilValue;
    }

    if (ps->next_token == END_OF_INPUT || ps->next_token == '\n' 
                                       || ps->next_token == ';') {
        *status = PARSE_NULL;
        return R_CurrentExpr = R_NilValue;
    }

    start_location(loc);
    res = parse_prog (flags);
    end_location(loc);

    if (res == NULL) {
        *status = PARSE_ERROR;
        return R_CurrentExpr = R_NilValue;
    }

    *status = PARSE_OK;
    return R_CurrentExpr = res;
}

/* -------------------------------------------------------------------------- 
   PARSING ENTRY POINTS.

   See the documentation at the start of this module. */

#define PARSE_INIT \
    struct parse_state new_parse_state; \
    struct parse_state *sv_ps = ps; \
    ps = &new_parse_state; \
    ps->token_loc.first_line = 0; \
    ps->token_loc.first_column = 0; \
    ps->token_loc.first_byte = 0; \
    ps->token_loc.first_parsed = 1; \
    ps->ParseContext[0] = 0; \
    ps->ParseContextLast = 0; \
    ps->ParseContextLine = 0; \
    ps->prevpos = 0; \
    ps->npush = 0;

#define PARSE_FINI \
    memcpy (R_ParseContext, ps->ParseContext, PARSE_CONTEXT_SIZE); \
    R_ParseContextLast = ps->ParseContextLast; \
    R_ParseContextLine = ps->ParseContextLine; \
    ps = sv_ps;


static int call_stream_getc(void) 
{ 
    return (*ps->stream_getc)(ps->stream_getc_arg);
}

attribute_hidden SEXP R_Parse1Stream (int (*getc) (void *), void *getc_arg, 
                                      ParseStatus *status, SrcRefState *state)
{
    PARSE_INIT

    source_location loc;
    SEXP res;

    ps->stream_getc = getc;
    ps->stream_getc_arg = getc_arg;
    ps->ptr_getc = call_stream_getc;
    ps->sr = state;
    ps->keep_source = state->keepSrcRefs;

    res = R_Parse1 (status, &loc);

    PARSE_FINI

    return res;
}


static SEXP R_Parse(int n, ParseStatus *status, SEXP srcfile)
{
    SEXP rval, tval, tlast, cur, refs, last_ref;
    SrcRefState state;
    source_location loc;
    int i;

    ps->sr = &state;
    R_InitSrcRefState (ps->sr, !isNull(srcfile) && !isString(srcfile));

    REPROTECT(ps->sr->SrcFile = srcfile, ps->sr->SrcFileProt);
    REPROTECT(ps->sr->Original = srcfile, ps->sr->OriginalProt);

    PROTECT(tval = CONS(R_NilValue,R_NilValue));
    tlast = tval;

    if (ps->sr->keepSrcRefs) {
        PROTECT(refs = CONS(R_NilValue,R_NilValue));
        last_ref = refs;
    }
    else
        PROTECT(refs = R_NilValue);
    
    ps->keep_source = ps->sr->keepSrcRefs;

    for(i = 0; ; ) {
	if(n >= 0 && i >= n) break;

	cur = R_Parse1(status,&loc);

	switch(*status) {
	case PARSE_NULL:
	    break;
	case PARSE_OK:
            SETCDR (tlast, CONS (cur, R_NilValue));
            tlast = CDR(tlast);
            if (ps->sr->keepSrcRefs) {
                SETCDR (last_ref, 
                        CONS (makeSrcref(&loc,ps->sr->SrcFile),R_NilValue));
                last_ref = CDR(last_ref);
            }
	    i++;
	    break;
	case PARSE_ERROR:
	    UNPROTECT(2); /* tval, refs */
	    R_FinalizeSrcRefState(ps->sr);
	    return R_NilValue;
	case PARSE_EOF:
	    goto finish;
	}
    }

finish:
    tval = CDR(tval);
    PROTECT(rval = allocVector(EXPRSXP, length(tval)));
    for (i = 0 ; i < LENGTH(rval) ; i++, tval = CDR(tval))
	SET_VECTOR_ELT(rval, i, CAR(tval));
    if (ps->sr->keepSrcRefs)
	attachSrcrefs(rval,CDR(refs));

    UNPROTECT(3); /* tval, refs, rval */
    R_FinalizeSrcRefState(ps->sr);
    *status = PARSE_OK;
    return rval;
}

static int text_getc(void)
{
    return R_TextBufferGetc(ps->textb_ptr);
}

SEXP R_ParseVector(SEXP text, int n, ParseStatus *status, SEXP srcfile)
{
    PARSE_INIT

    SEXP rval;
    TextBuffer textb;

    PROTECT(text);
    R_TextBufferInit(&textb, text);
    UNPROTECT(1);

    ps->textb_ptr = &textb;
    ps->ptr_getc = text_getc;

    rval = R_Parse(n, status, srcfile);

    R_TextBufferFree(&textb);

    PARSE_FINI

    return rval;
}


SEXP R_ParseStream (int (*getc) (void *), void *getc_arg, 
                    int n, ParseStatus *status, SEXP srcfile)
{
    PARSE_INIT

    SEXP res;

    ps->stream_getc = getc;
    ps->stream_getc_arg = getc_arg;
    ps->ptr_getc = call_stream_getc;

    res = R_Parse (n, status, srcfile);

    PARSE_FINI

    return res;
}


/* --------------------------------------------------------------------------
   TEXT BUFFER

   This is used as the buffer for NumericValue, SpecialValue and
   SymbolValue.  None of these could conceivably need 8192 bytes.

   For inclusion in parse data, it is also used to store text from 
   strings, or a  message saying the text was truncated, and text
   from comments that fit. */

static char yytext[MAXELTSIZE];

#define DECLARE_YYTEXT_BUFP(bp) char *bp = yytext

#define YYTEXT_PUSH(c, bp) do { \
    if ((bp) - yytext >= sizeof(yytext) - 1) \
        error(_("input buffer overflow at line %d"), ps->sr->xxlineno); \
    *(bp)++ = (c); \
} while(0)


/* --------------------------------------------------------------------------
   ROUTINES FOR CREATING NUMERIC AND STRING VALUES
*/


static SEXP mkReal(const char *s)
{
    return ScalarRealMaybeConst(R_atof(s));
}


static SEXP mkInteger(const char *s)
{
    double f = R_atof(s);  /* or R_strtol? */
    return ScalarIntegerMaybeConst((int) f);
}


static SEXP mkComplex(const char *s)
{
    SEXP t = R_NilValue;
    double f;
    f = R_atof(s); /* FIXME: make certain the value is legitimate. */

    t = allocVector(CPLXSXP, 1);
    COMPLEX(t)[0].r = 0;
    COMPLEX(t)[0].i = f;

    return t;
}


static int NumericValue(int c)
{
    int seendot = (c == '.');
    int seenexp = 0;
    int last = c;
    int nd = 0;
    int asNumeric = 0;
    int count = 1; /* The number of characters seen */

    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    /* We don't care about other than ASCII digits */
    while (isdigit(c = xxgetc()) || c == '.' || c == 'e' || c == 'E'
	   || c == 'x' || c == 'X' || c == 'L')
    {
	count++;
	if (c == 'L') /* must be at the end.  Won't allow 1Le3 (at present). */
	    break;

	if (c == 'x' || c == 'X') {
	    if (count > 2 || last != '0') break;  /* 0x must be first */
	    YYTEXT_PUSH(c, yyp);
	    while(isdigit(c = xxgetc()) || ('a' <= c && c <= 'f') ||
		  ('A' <= c && c <= 'F') || c == '.') {
		YYTEXT_PUSH(c, yyp);
		nd++;
	    }
	    if (nd == 0) return ERROR;
	    if (c == 'p' || c == 'P') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c) && c != '+' && c != '-') return ERROR;
		if (c == '+' || c == '-') {
		    YYTEXT_PUSH(c, yyp);
		    c = xxgetc();
		}
		for(nd = 0; isdigit(c); c = xxgetc(), nd++)
		    YYTEXT_PUSH(c, yyp);
		if (nd == 0) return ERROR;
	    }
	    break;
	}
	if (c == 'E' || c == 'e') {
	    if (seenexp)
		break;
	    seenexp = 1;
	    seendot = seendot == 1 ? seendot : 2;
	    YYTEXT_PUSH(c, yyp);
	    c = xxgetc();
	    if (!isdigit(c) && c != '+' && c != '-') return ERROR;
	    if (c == '+' || c == '-') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c)) return ERROR;
	    }
	}
	if (c == '.') {
	    if (seendot)
		break;
	    seendot = 1;
	}
	YYTEXT_PUSH(c, yyp);
	last = c;
    }
    YYTEXT_PUSH('\0', yyp);
    /* Make certain that things are okay. */
    if(c == 'L') {
	double a = R_atof(yytext);
	int b = (int) a;
	/* We are asked to create an integer via the L, so we check that the
	   double and int values are the same. If not, this is a problem and we
	   will not lose information and so use the numeric value.
	*/
	if(a != (double) b) {
            if(seendot == 1 && seenexp == 0)
		warning(
                _("integer literal %sL contains decimal; using numeric value"),
                yytext);
	    else
		warning(
                _("non-integer value %s qualified with L; using numeric value"),
                yytext);
	    asNumeric = 1;
	    seenexp = 1;
	}
    }

    if(c == 'i') {
	ps->next_token_val = mkComplex(yytext);
    } else if(c == 'L' && asNumeric == 0) {
	if (seendot == 1 && seenexp == 0)
	    warning(_("integer literal %sL contains unnecessary decimal point"),
                    yytext);
	ps->next_token_val = mkInteger(yytext);
    } else {
	if(c != 'L')
	    xxungetc(c);
	ps->next_token_val = mkReal(yytext);
    }

    return NUM_CONST;
}


/* Strings may contain the standard ANSI escapes and octal specifications of 
   the form \o, \oo or \ooo, where 'o' is an octal digit. 

   If a string contains \u escapes that are not valid in the current locale, 
   we should switch to UTF-8 for that string.  Needs Unicode wide-char support.
*/

static int mbcs_get_next(int c, wchar_t *wc)
{
    int i, res, clen = 1; char s[9];
    mbstate_t mb_st;

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    s[i] = xxgetc();
	    if(s[i] == R_EOF) 
                error(_("EOF whilst reading MBCS char at line %d"), 
                        ps->sr->xxlineno);
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbrtowc(wc, s, clen, NULL);
	if(res == -1) 
            error(_("invalid multibyte character in parser at line %d"), 
                    ps->sr->xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    mbs_init(&mb_st);
	    res = mbrtowc(wc, s, clen, &mb_st);
	    if(res >= 0) break;
	    if(res == -1)
		error(_("invalid multibyte character in parser at line %d"),
                         ps->sr->xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if(c == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#if defined(Win32) || defined(__STDC_ISO_10646__)

#define mbcs_get_next2 mbcs_get_next
typedef wchar_t ucs_t;

#else

#define WC_NOT_UNICODE 
typedef unsigned int ucs_t;

static int mbcs_get_next2(int c, ucs_t *wc)
{
    int i, res, clen = 1; char s[9];

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if ((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    s[i] = xxgetc();
	    if(s[i] == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbtoucs(wc, s, clen);
	if (res == -1) 
            error(_("invalid multibyte character in parser at line %d"),
                     ps->sr->xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    res = mbtoucs(wc, s, clen);
	    if (res >= 0) break;
	    if (res == -1)
		error(_("invalid multibyte character in parser at line %d"),
                         ps->sr->xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if (c == R_EOF)
                error(_("EOF whilst reading MBCS char at line %d"),
                         ps->sr->xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#endif


static SEXP mkStringUTF8(const ucs_t *wcs, int cnt)
{
    SEXP t;
    int nb;

/* NB: cnt includes the terminator */
#ifdef Win32
    nb = cnt*4; /* UCS-2/UTF-16 so max 4 bytes per wchar_t */
#else
    nb = cnt*6;
#endif
    char s[nb];
    R_CheckStack();
    memset(s, 0, nb); /* safety */
#ifdef WC_NOT_UNICODE
    {
	char *ss;
	for(ss = s; *wcs; wcs++) ss += ucstoutf8(ss, *wcs);
    }
#else
    wcstoutf8(s, wcs, nb);
#endif
    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharCE(s, CE_UTF8));
    UNPROTECT(1);
    return t;
}


static SEXP mkString2(const char *s, int len, Rboolean escaped)
{
    SEXP t;
    cetype_t enc = CE_NATIVE;

    if(known_to_be_latin1) enc= CE_LATIN1;
    else if(!escaped && known_to_be_utf8) enc = CE_UTF8;

    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharLenCE(s, len, enc));
    UNPROTECT(1);
    return t;
}


/* forSymbol is true when parsing backticked symbols */

static int StringValue(int c, Rboolean forSymbol)
{
    int quote = c;
    Rboolean oct_or_hex = FALSE, use_wcs = FALSE, currtext_truncated = FALSE;

    char st0[MAXELTSIZE];
    unsigned int nstext = MAXELTSIZE;
    char *stext = st0, *bp = st0;

#   define STEXT_PUSH(c) do {               \
	unsigned int nc = bp - stext;       \
	if (nc >= nstext - 1) {             \
	    char *old = stext;              \
	    nstext *= 2;                    \
	    stext = malloc(nstext);         \
	    if (!stext) {                   \
               if (old != st0) free(old);   \
               error(_("unable to allocate buffer for long string at line %d"),\
                     ps->sr->xxlineno); \
            }                               \
	    memmove(stext, old, nc);        \
	    if (old != st0) free(old);	    \
	    bp = stext+nc; }		    \
	*bp++ = (c);                        \
    } while(0)

    int wcnt = 0;
    ucs_t wcs[10001];

#   define WTEXT_PUSH(c) do { if(wcnt <= 10000) wcs[wcnt++] = c; } while(0)

    char currtext[1010], *ct = currtext;

#   define CTEXT_PUSH(c) do {                     \
	if (ct - currtext >= 1000) {              \
            memmove(currtext, currtext+100, 901); \
            memmove(currtext, "... ", 4);         \
            ct -= 100;                            \
	    currtext_truncated = TRUE;            \
        }                                         \
	*ct++ = (c);                              \
    } while(0)

#   define CTEXT_POP() (ct--)

    CTEXT_PUSH(c); /* push opening quote */
    while ((c = xxgetc()) != R_EOF && c != quote) {
	CTEXT_PUSH(c);
	if (c == '\n') {
	    xxungetc(c); CTEXT_POP();
	    /* Fix suggested by Mark Bravington to allow multiline strings
	     * by pretending we've seen a backslash. Was:
	     * return ERROR;
	     */
	    c = '\\';
	}
	if (c == '\\') {
	    c = xxgetc(); CTEXT_PUSH(c);
	    if ('0' <= c && c <= '7') {
		int octal = c - '0';
		if ('0' <= (c = xxgetc()) && c <= '7') {
		    CTEXT_PUSH(c);
		    octal = 8 * octal + c - '0';
		    if ('0' <= (c = xxgetc()) && c <= '7') {
			CTEXT_PUSH(c);
			octal = 8 * octal + c - '0';
		    } else
			xxungetc(c);
		} else
		    xxungetc(c);
		if (!octal) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"), 
                          ps->sr->xxlineno);
                }
		c = octal;
		oct_or_hex = TRUE;
	    }
	    else if(c == 'x') {
		int val = 0; int i, ext;
		for(i = 0; i < 2; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c); CTEXT_POP();
			if (i == 0) { /* was just \x */
			    *ct = '\0';
                            if (stext != st0) free(stext);
			    errorcall(R_NilValue, 
                             _("'\\x' used without hex digits in character string starting \"%s\""), 
                             currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if (!val) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"), 
                          ps->sr->xxlineno);
                }
		c = val;
		oct_or_hex = TRUE;
	    }
	    else if (c == 'u' || c == 'U') {
		unsigned int val = 0; int i, ext; 
		Rboolean delim = FALSE;
                int bigU = c == 'U';

		if(forSymbol) {
                    if (stext != st0) free(stext);
		    error (bigU ? _("\\Uxxxxxxxx sequences not supported inside backticks (line %d)")
                                : _("\\uxxxx sequences not supported inside backticks (line %d)"), 
                      ps->sr->xxlineno);
                }
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		}
                else
                    xxungetc(c);
		for (i = 0; i < (bigU ? 8 : 4); i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c); CTEXT_POP();
			if (i == 0) { /* was just \u or \U */
			    *ct = '\0';
                            if (stext != st0) free(stext);
			    errorcall (R_NilValue, 
                              bigU ? _("'\\U' used without hex digits in character string starting \"%s\"")
                                   : _("'\\u' used without hex digits in character string starting \"%s\""), 
                              currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if (c != '}') {
                        if (stext != st0) free(stext);
			error (bigU ? _("invalid \\U{xxxxxxxx} sequence (line %d)")
                                    : _("invalid \\u{xxxx} sequence (line %d)"),
			      ps->sr->xxlineno);
                    }
		}
		if (!val) {
                    if (stext != st0) free(stext);
		    error(_("nul character not allowed (line %d)"),
                          ps->sr->xxlineno);
                }
		WTEXT_PUSH(val); /* this assumes wchar_t is Unicode */
		use_wcs = TRUE;
		continue;
	    }
	    else {
		switch (c) {
		case 'a':
		    c = '\a';
		    break;
		case 'b':
		    c = '\b';
		    break;
		case 'f':
		    c = '\f';
		    break;
		case 'n':
		    c = '\n';
		    break;
		case 'r':
		    c = '\r';
		    break;
		case 't':
		    c = '\t';
		    break;
		case 'v':
		    c = '\v';
		    break;
		case '\\':
		    c = '\\';
		    break;
		case '"':
		case '\'':
		case ' ':
		case '`':
		case '\n':
		    break;
		default:
		    *ct = '\0';
                    if (stext != st0) free(stext);
		    errorcall(R_NilValue, 
                       _("'\\%c' is an unrecognized escape in character string starting \"%s\""), 
                       c, currtext);
		}
	    }
	} else if(mbcslocale) {
	    int i, clen;
	    ucs_t wc;
	    clen = mbcs_get_next2(c, &wc);
	    WTEXT_PUSH(wc);
	    for(i = 0; i < clen - 1; i++){
		STEXT_PUSH(c);
		c = xxgetc();
		if (c == R_EOF) break;
		CTEXT_PUSH(c);
		if (c == '\n') {
		    xxungetc(c); CTEXT_POP();
		    c = '\\';
		}
	    }
	    if (c == R_EOF) break;
	    STEXT_PUSH(c);
	    continue;
	}
	STEXT_PUSH(c);
	if ((unsigned int) c < 0x80) WTEXT_PUSH(c);
	else { /* have an 8-bit char in the current encoding */
#           ifdef WC_NOT_UNICODE
	        ucs_t wc;
                char s[2] = " ";
                s[0] = c;
                mbtoucs(&wc, s, 2);
#           else
                wchar_t wc;
                char s[2] = " ";
                s[0] = c;
                mbrtowc(&wc, s, 2, NULL);
#           endif
	    WTEXT_PUSH(wc);
	}
    }

    if (c == R_EOF) {
        ps->next_token_val = R_NilValue;
        yytext[0] = 0;
        if (stext != st0) free(stext);
    	return ERROR;
    }

    CTEXT_PUSH(c); /* push closing quote */
    CTEXT_PUSH('\0');

    /* Copy the string as in the source to yytext, to use for parse data,
       of copy a message about it being to long to yytext. */

    if (!currtext_truncated)
        strcpy(yytext, currtext);
    else if (forSymbol || !use_wcs) {
        size_t total = strlen(stext);
        snprintf (yytext, MAXELTSIZE, "[%u chars quoted with '%c']",
                  (unsigned int)total, quote);
    }
    else 
        snprintf (yytext, MAXELTSIZE, "[%d wide chars quoted with '%c']", 
                  wcnt, quote);

    /* Create symbol or string from text in stext or wcs. */

    STEXT_PUSH('\0');
    if (forSymbol) {
	ps->next_token_val = install(stext);
	if (stext != st0) free(stext);
	return SYMBOL;
    } 
    else {
	if (use_wcs) {
	    if (oct_or_hex) {
                if (stext != st0) free(stext);
		error(_("mixing Unicode and octal/hex escapes in a string is not allowed"));
            }
	    if (wcnt > 10000) {
                if (stext != st0) free(stext);
		error(_("string at line %d containing Unicode escapes not in this locale\nis too long (max 10000 chars)"),
                      ps->sr->xxlineno);
            }
            WTEXT_PUSH(0);
            ps->next_token_val = mkStringUTF8(wcs,wcnt); /*incl terminator*/
	} 
        else
	    ps->next_token_val = mkString2(stext,  bp - stext - 1, oct_or_hex);
	if (stext != st0) free(stext);
	return STR_CONST;
    }
}


/* --------------------------------------------------------------------------
   THE LEXICAL ANALYZER
*/

/* Table of syntactic keywords and symbolic constants. */

static struct { char *name; int token; } keywords[] = {
    { "NULL",	    NULL_CONST },
    { "NA",	    NUM_CONST  },  /* order of next 9 is significant below */
    { "TRUE",	    NUM_CONST  },
    { "FALSE",	    NUM_CONST  },
    { "Inf",	    NUM_CONST  },
    { "NaN",	    NUM_CONST  },
    { "NA_integer_", NUM_CONST },
    { "NA_real_",    NUM_CONST },
    { "NA_character_", NUM_CONST },
    { "NA_complex_", NUM_CONST },
    { "function",   FUNCTION   },
    { "while",	    WHILE      },
    { "repeat",	    REPEAT     },
    { "for",	    FOR	       },
    { "if",	    IF	       },
    { "in",	    IN	       },
    { "else",	    ELSE       },
    { "next",	    NEXT       },
    { "break",	    BREAK      },
    { "...",	    SYMBOL     },
    { 0,	    0	       }
};


/* Check whether a string is a keyword.  Returns 0 if it is not a keyword.
   Returns 1 if it is a keyword, and also sets next_token_val to the
   associated value (constant, symbol, or R_NilValue for 'in' and 'else'). */

static int KeywordLookup(const char *s)
{
    int i;
    for (i = 0; keywords[i].name; i++) {
	if (strcmp(keywords[i].name, s) == 0) {
	    switch (keywords[i].token) {
	    case NULL_CONST:
		ps->next_token_val = R_NilValue;
		break;
	    case NUM_CONST:
                switch(i) {
                case 1:
                    ps->next_token_val = ScalarLogicalMaybeConst(NA_LOGICAL);
                    break;
                case 2:
                    ps->next_token_val = ScalarLogicalMaybeConst(1);
                    break;
                case 3:
                    ps->next_token_val = ScalarLogicalMaybeConst(0);
                    break;
                case 4:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = R_PosInf;
                    break;
                case 5:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = R_NaN;
                    break;
                case 6:
                    ps->next_token_val = ScalarIntegerMaybeConst(NA_INTEGER);
                    break;
                case 7:
                    ps->next_token_val = allocVector1REAL();
                    REAL(ps->next_token_val)[0] = NA_REAL;
                    break;
                case 8:
                    ps->next_token_val = allocVector(STRSXP, 1);
                    SET_STRING_ELT(ps->next_token_val, 0, NA_STRING);
                    break;
                case 9:
                    ps->next_token_val = allocVector(CPLXSXP, 1);
                    COMPLEX(ps->next_token_val)[0].r = NA_REAL;
                    COMPLEX(ps->next_token_val)[0].i = NA_REAL;
                    break;
                }
		break;
	    case FUNCTION:
		ps->next_token_val = R_FunctionSymbol;
		break;
	    case WHILE:
		ps->next_token_val = R_WhileSymbol;
		break;
	    case REPEAT:
		ps->next_token_val = R_RepeatSymbol;
		break;
	    case FOR:
		ps->next_token_val = R_ForSymbol;
		break;
	    case IF:
		ps->next_token_val = R_IfSymbol;
		break;
	    case NEXT:
		ps->next_token_val = R_NextSymbol;
		break;
	    case BREAK:
		ps->next_token_val = R_BreakSymbol;
		break;
		break;
	    case IN:
	    case ELSE:
		ps->next_token_val = R_NilValue;
		break;
	    case SYMBOL:
		ps->next_token_val = install(s);
		break;
	    }
	    return keywords[i].token;
	}
    }
    return 0;
}


/* Process a special operator beginning with '%', setting next_token_val
   to a symbol for it.  The value returned is SYMBOL or ERROR (if operator
   is incomplete). */

static int SpecialValue(int c)
{
    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    while ((c = xxgetc()) != R_EOF && c != '%') {
	if (c == '\n') {
	    xxungetc(c);
	    return ERROR;
	}
	YYTEXT_PUSH(c, yyp);
    }
    if (c == '%')
	YYTEXT_PUSH(c, yyp);
    YYTEXT_PUSH('\0', yyp);
    ps->next_token_val = install(yytext);
    return SPECIAL;
}


/* Process a symbol value, putting the symbol in next_token_val (or
   the corresponding numeric or logical value, for constants).  The
   return value is SYMBOL for regular symbols, NUM_CONST for constants,
   and the appropriate token code for reserved words. */

static int SymbolValue(int c)
{
    int kw;
    DECLARE_YYTEXT_BUFP(yyp);
    if(mbcslocale) {
	wchar_t wc; int i, clen;
	clen = mbcs_get_next(c, &wc);
	while(1) {
	    /* at this point we have seen one char, so push its bytes
	       and get one more */
	    for(i = 0; i < clen; i++) {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
	    }
	    if(c == R_EOF) break;
	    if(c == '.' || c == '_') {
		clen = 1;
		continue;
	    }
	    clen = mbcs_get_next(c, &wc);
	    if(!iswalnum(wc)) break;
	}
    } else
	do {
	    YYTEXT_PUSH(c, yyp);
	} while ((c = xxgetc()) != R_EOF &&
		 (isalnum(c) || c == '.' || c == '_'));
    xxungetc(c);
    YYTEXT_PUSH('\0', yyp);
    if ((kw = KeywordLookup(yytext))) 
	return kw;
    
    ps->next_token_val = install(yytext);
    return SYMBOL;
}


/* Skip whitespace characters, starting with the character passed,
   and stopping on '\n', R_EOF, or a non-whitespace character.  The 
   character stopped on is returned. */

static int skip_whitespace (int c)
{
    int NBSP = ' ';

#if defined(Win32) || defined(__STDC_ISO_10646__)
    int i, clen;
    wchar_t wc;  /* wctype functions need Unicode wchar_t */
#endif

#ifdef Win32
    if (!mbcslocale) NBSP = 0xa0; /* 0xa0 is NBSP in 8-bit Windows locales */
#endif 

    for (;;) {

        if (c == '\n' || c == R_EOF)
            return c;

        if (c != ' ' && c != '\t' && c != '\f' && c != NBSP) {
#           if defined(Win32) || defined(__STDC_ISO_10646__)
            {   if (mbcslocale) {
                    if ((unsigned int) c < 0x80)
                        return c;
                    clen = mbcs_get_next(c, &wc);
                    if ( ! Ri18n_iswctype (wc, Ri18n_wctype("blank")))
                        return c;
                    for (i = 1; i < clen; i++)
                        c = xxgetc();
                }
                else
                    return c;
            }
#           else
                return c;
#           endif
        }

        c = xxgetc();
    }
}


/* Set the name of the source file that text is coming from. */

static void set_parse_filename(SEXP newname) 
{
    SEXP class;

    if (!isEnvironment(ps->sr->SrcFile)) 
        return;

    PROTECT(newname);    

    SEXP oldname = findVar(install("filename"), ps->sr->SrcFile);
    if (isString(oldname) && length(oldname) > 0 &&
         strcmp (CHAR(STRING_ELT(oldname,0)), CHAR(STRING_ELT(newname,0)))==0) {
        UNPROTECT(1);
        return;
    }

    REPROTECT(ps->sr->SrcFile =
                 NewEnvironment (R_NilValue, R_NilValue, R_EmptyEnv),
              ps->sr->SrcFileProt);
    set_var_in_frame (install("filename"), newname, ps->sr->SrcFile,
                      TRUE, 3);

    if (ps->sr->keepSrcRefs) {
        set_var_in_frame (install("original"), ps->sr->Original, 
                          ps->sr->SrcFile, TRUE, 3);
        PROTECT(class = allocVector(STRSXP, 2));
        SET_STRING_ELT(class, 0, mkChar("srcfilealias"));
        SET_STRING_ELT(class, 1, mkChar("srcfile"));
        setAttrib(ps->sr->SrcFile, R_ClassSymbol, class);
        UNPROTECT(1);
    } 

    UNPROTECT(1);
}


/* Process a #line nn [ file ] directive.  The #line part will have already
   been read.  Returns the character after the directive. */

static int processLineDirective()
{
    int c, tok, linenumber;

    c = skip_whitespace(xxgetc());
    if (!isdigit(c)) 
        return c;
    tok = NumericValue(c);
    linenumber = atoi(yytext);
    c = skip_whitespace(xxgetc());
    if (c == '"') 
        tok = StringValue(c, FALSE);
    else
    	xxungetc(c);
    if (tok == STR_CONST) 
	set_parse_filename(ps->next_token_val);

    while ((c = xxgetc()) != '\n' && c != R_EOF) /* skip */ ;

    ps->sr->xxlineno = linenumber;

    /* Don't change xxparseno here, it counts parsed lines, not official lines*/

    /* Context report shouldn't show the directive */

    ps->ParseContext[ps->ParseContextLast] = '\0'; 

    return c;
}


/* Skip a comment, returning the character ending it ('\n' or R_EOF).
   Also processes comments that are #line directives.  The initial #
   will have already been read. */

static int skip_comment (void)
{
    Rboolean maybeLine = (ps->sr->xxcolno == 1);
    source_location loc;
    int c, i;

    loc.first_parsed = ps->sr->xxparseno;
    loc.first_column = ps->sr->xxcolno;

    c = '#';

    if (maybeLine) {
    	static const char lineDirective[] = "#line";
    	for (i = 1; i < 5; i++) {
    	    c = xxgetc();
  	    if (c != lineDirective[i]) {
  	    	maybeLine = FALSE;
  	    	break;
  	    }
  	}
  	if (maybeLine)     
	    c = processLineDirective();
    }

    while (c != '\n' && c != R_EOF)
	c = xxgetc();

    if (ps->keep_source) {

        SEXP rec;

        if (c == '\n') xxungetc(c);  /* newline shouldn't be part of record */

        rec = start_parseData_record (&loc, "COMMENT", "", TRUE);
        loc.last_parsed = ps->sr->xxparseno;
        loc.last_column = ps->sr->xxcolno;
        end_parseData_record(rec,&loc);

        if (c == '\n') xxgetc();
    }

    return c;
}


/* Called following '.'.  We only care if it's an ANSI digit or not. */

static int nextisdigit(void)
{
    int k, c;
    c = xxgetc();
    k = isdigit(c);
    xxungetc(c);
    return k;
}


/* Returns whether the next character is the one passed, advancing to
   the next character only if it is. */

static int nextchar(int expect)
{
    int c = xxgetc();
    if (c == expect)
	return 1;
    else {
	xxungetc(c);
        return 0;
    }
}


/* Get a token.

   Passed the first non-whitespace character of the next token.  Returns
   the token code (or ERROR if the next token is malformed).  Will also
   set next_token_val to an associated SEXP (R_NilValue if none).  This
   SEXP must be protected by the caller if necessary.

   The character after the token may have been looked at, but if so xxungetc
   will have been called to put it back. */

static int token (int c)
{
    wchar_t wc;

    ps->next_token_val = R_NilValue;

    /* Hard and soft end of file.  Soft end of file comes at the end of a
       line of interactive input, which may or may not be the actual end. */

    if (c == R_EOF)
        return END_OF_INPUT;

    if (c == '\n')
        return c;

    /* Literal numbers - since either digits or symbols can start with '.',
       we need to check whether the next character is a digit. */

    if (isdigit(c) || c == '.' && nextisdigit())
        return NumericValue(c);

    /* Literal strings */

    if (c == '\"' || c == '\'')
	return StringValue(c, FALSE);

    /* Special functions */

    if (c == '%')
	return SpecialValue(c);

    /* Symbols (functions, constants and variables) */

    if (c == '`')
	return StringValue(c, TRUE);
    if (c == '.') 
        return SymbolValue(c);
    if(mbcslocale) {
	mbcs_get_next(c, &wc);
	if (iswalpha(wc)) return SymbolValue(c);
    }
    else
	if (isalpha(c)) return SymbolValue(c);

    /* Simple and compound tokens */

    switch (c) {
    case '<':
	if (nextchar('=')) {
	    ps->next_token_val = R_LeSymbol;
	    return LE;
	}
	if (nextchar('-')) {
	    ps->next_token_val = R_LocalAssignSymbol;
	    return LEFT_ASSIGN;
	}
	if (nextchar('<')) {
	    if (nextchar('-')) {
		ps->next_token_val = R_GlobalAssignSymbol;
		return LEFT_ASSIGN;
	    }
	    else
		return ERROR;
	}
	ps->next_token_val = R_LtSymbol;
	return LT;
    case '-':
	if (nextchar('>')) {
	    if (nextchar('>')) {
		ps->next_token_val = R_GlobalRightAssignSymbol;
		return RIGHT_ASSIGN;
	    }
	    else {
		ps->next_token_val = R_LocalRightAssignSymbol;
		return RIGHT_ASSIGN;
	    }
	}
	ps->next_token_val = R_SubSymbol;
	return '-';
    case '>':
	if (nextchar('=')) {
	    ps->next_token_val = R_GeSymbol;
	    return GE;
	}
	ps->next_token_val = R_GtSymbol;
	return GT;
    case '!':
	if (nextchar('=')) {
	    ps->next_token_val = R_NeSymbol;
	    return NE;
	}
	ps->next_token_val = R_NotSymbol;
	return '!';
    case '=':
	if (nextchar('=')) {
	    ps->next_token_val = R_EqSymbol;
	    return EQ;
	}
	ps->next_token_val = R_EqAssignSymbol;
	return EQ_ASSIGN;
    case ':':
	if (nextchar(':')) {
	    if (nextchar(':')) {
		ps->next_token_val = R_TripleColonSymbol;
		return NS_GET_INT;
	    }
	    else {
		ps->next_token_val = R_DoubleColonSymbol;
		return NS_GET;
	    }
	}
	if (nextchar('=')) {
	    ps->next_token_val = R_ColonAssignSymbol;
	    return COLON_ASSIGN;
	}
	ps->next_token_val = R_ColonSymbol;
	return ':';
    case '&':
	if (nextchar('&')) {
	    ps->next_token_val = R_And2Symbol;
	    return AND2;
	}
	ps->next_token_val = R_AndSymbol;
	return AND;
    case '|':
	if (nextchar('|')) {
	    ps->next_token_val = R_Or2Symbol;
	    return OR2;
	}
	ps->next_token_val = R_OrSymbol;
	return OR;
    case '{':
	ps->next_token_val = R_BraceSymbol;
	return c;
    case '}':
	return c;
    case '(':
	ps->next_token_val = R_ParenSymbol;
	return c;
    case ')':
	return c;
    case '[':
	if (nextchar('[')) {
	    ps->next_token_val = R_Bracket2Symbol;
	    return LBB;
	}
	ps->next_token_val = R_BracketSymbol;
	return c;
    case ']':
	return c;
    case '?':
	ps->next_token_val = R_QuerySymbol;
	return c;
    case '*':
	if (nextchar('*')) {
            /* We accept ** as a synonym for ^, with its own token type 
               and primitive definition. */
	    ps->next_token_val = R_Expt2Symbol;
            return EXPT2;
        }
        ps->next_token_val = R_MulSymbol;
	return c;
    case '+':
        ps->next_token_val = R_AddSymbol;
        return c;
    case '/':
        ps->next_token_val = R_DivSymbol;
        return c;
    case '^':
        ps->next_token_val = R_ExptSymbol;
        return c;
    case '~':
        ps->next_token_val = R_TildeSymbol;
        return c;
    case '$':
        ps->next_token_val = R_DollarSymbol;
        return c;
    case '@':
        ps->next_token_val = R_AtSymbol;
        return c;
    default:
	return c;
    }
}


/* Get the next token after skipping whitespace and put it in
   next_token.  Also sets next_token_val, newline_before_token,
   token_loc, and prev_token_loc.  Always sets newline_before_token
   to 1 when returning END_OF_INPUT or '\n', regardless of 
   whether a newline was actually present before. 

   Returns 0 if end of file was immediately encountered, with no
   whitespace before, and 1 if not (even when END_OF_INPUT is the 
   next token). */

static int get_next_token(void)
{
    int c, val;

    ps->prev_token_loc = ps->token_loc;

    ps->newline_before_token = 0;

    c = xxgetc();
    val = c != R_EOF;

    c = skip_whitespace(c);
    if (c == '#')
        c = skip_comment();
    if (c == '\n' || c == R_EOF)
        ps->newline_before_token = 1;

    ps->token_loc.first_line   = ps->sr->xxlineno;
    ps->token_loc.first_column = ps->sr->xxcolno;
    ps->token_loc.first_byte   = ps->sr->xxbyteno;
    ps->token_loc.first_parsed = ps->sr->xxparseno;

    ps->next_token = token(c);

    ps->token_loc.last_line    = ps->sr->xxlineno;
    ps->token_loc.last_column  = ps->sr->xxcolno;
    ps->token_loc.last_byte    = ps->sr->xxbyteno;
    ps->token_loc.last_parsed  = ps->sr->xxparseno;

    if (ps->next_token != END_OF_INPUT && ps->next_token != '\n') {
        SEXP rec;
        char t[4] = { '\'', (char) ps->next_token, '\'', 0 };
        rec = start_parseData_record (&ps->token_loc, ps->next_token < 256 ? t
                                        : pdata_token_name[ps->next_token-256],
                                      "", TRUE);
        end_parseData_record (rec, &ps->token_loc);
    }

    return val;
}


/* --------------------------------------------------------------------------
   ROUTINE USED ONLY EXTERNALLY
*/

/* Return 1 if 'name' is a valid name or 0 otherwise.  Not used by the
   parser itself, but defined here since it needs to know which names 
   are reserved words. */

int isValidName(const char *name)
{
    const char *p = name;
    int i;

    if (strcmp(name, "...") == 0)
        return 1;

    if(mbcslocale) {
	/* the only way to establish which chars are alpha etc is to
	   use the wchar variants */
	int n = strlen(name), used;
	wchar_t wc;
	used = Mbrtowc(&wc, p, n, NULL); p += used; n -= used;
	if (used == 0)
            return 0;
	if (wc != L'.' && !iswalpha(wc))
            return 0;
	if (wc == L'.') {
	    /* We don't care about other than ASCII digits */
	    if (isdigit(0xff & (int)*p))
                return 0;
	    /* Mbrtowc(&wc, p, n, NULL); if(iswdigit(wc)) return 0; */
	}
	while ((used = Mbrtowc(&wc, p, n, NULL))) {
	    if (!(iswalnum(wc) || wc == L'.' || wc == L'_'))
                break;
	    p += used; n -= used;
	}
	if (*p != '\0')
            return 0;
    } else {
	int c = 0xff & *p++;
	if (c != '.' && !isalpha(c) )
            return 0;
	if (c == '.' && isdigit(0xff & (int)*p))
            return 0;
	while ( c = 0xff & *p++, (isalnum(c) || c == '.' || c == '_') ) ;
	if (c != '\0')
            return 0;
    }

    /* Check whether it's a reserved word. */

    for (i = 0; keywords[i].name != NULL; i++)
	if (strcmp(keywords[i].name, name) == 0)
            return 0;

    return 1;
}
