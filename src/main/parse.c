/*
 *  pqR : A pretty quick version of R
 *  Copyright (C) 2013, 2014, 2015 by Radford M. Neal
 *
 *  Based on R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995, 1996, 1997  Robert Gentleman and Ross Ihaka
 *  Copyright (C) 1997--2010  The R Development Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#define USE_FAST_PROTECT_MACROS
#include "IOStuff.h"		/*-> Defn.h */
#include "Fileio.h"
#include "Parse.h"
#include <R_ext/Print.h>

#if !defined(__STDC_ISO_10646__) && (defined(__APPLE__) || defined(__FreeBSD__))
/* This may not be 100% true (see the comment in rlocales.h),
   but it seems true in normal locales */
# define __STDC_ISO_10646__
#endif


/* --------------------------------------------------------------------------
   PARSING ENTRY POINTS PROVIDED
 
   There are separate entry points for parsing IoBuffers (interactve
   use), files, and R character strings.  The entry points provide the
   same functionality; they just set things up in slightly different
   ways.
 
   The following routines parse a single expression:
 
       SEXP R_Parse1File (FILE *fp, int gencode, ParseStatus *status, 
                           SrcRefState *state)
         (used for R_ReplFile in main.c)
 
       SEXP R_Parse1Buffer (IoBuffer *buffer, int gencode, ParseStatus *status)

         (used for ReplIteration and R_ReplDLLdo1 in main.c)
 
   The following routines parse several expressions and return their
   values in a single expression vector.
 
       SEXP R_ParseVector (SEXP *text, int n, ParseStatus *status, SEXP srcfile)

         (public, and used by parse(text=) in file source.c)

       SEXP R_ParseFile (FILE *fp, int n, ParseStatus *status, SEXP srcfile)

         (used for do_edit in file edit.c)
 
       SEXP R_ParseBuffer (IoBuffer *buffer, int n, ParseStatus *status, 
                           SEXP prompt, SEXP srcfile)

         (used by parse(file="") in file source.c)
 
       SEXP R_ParseConn (Rconnection con, int n, ParseStatus *status, 
                         SEXP srcfile)

         (used by parse(file=) in file source.c)
 
   The success of the parse is indicated as folllows:
 
 	status = PARSE_NULL       - there was no statement to parse
 		 PARSE_OK	  - complete statement
 		 PARSE_INCOMPLETE - incomplete statement
 		 PARSE_ERROR      - syntax error
 		 PARSE_EOF	  - end of file
 
   In ReplIteration and Replconsole in main.c, the INCOMPLETE status is used
   to determine the number of lines to read for interactive input, with 
   additional lines being read until INCOMPLETE status is no longer returned.

   R_InitSrcRefState and R_FinalizeSrcRefState are also currently exposed.

   All the above are declared in Parse.h and R_ext/Parse.h.

   This module also defines the isValidName function, which needs to know
   the list of reserved words.
*/


/* --------------------------------------------------------------------------
   GRAMMAR FROM THE OLD BISON VERSION OF THE PARSER, WITHOUT THE ACTIONS

   The parser was previously a bottom-up one, generated by Bison.  It is
   now a top-down one, done by recursive descent, but there are traces
   of the old Bison version in some names and comments.  The grammar
   below is now shown just for (possibly out-of-date) documentation.

   Note that the preedence table given is misleading, since the declared 
   precedence applies only when the grammar is ambiguous. */

#if 0

/* This is the precedence table, low to high */

%left		'?'
%left		LOW WHILE FOR REPEAT
%right		IF
%left		ELSE
%right		LEFT_ASSIGN
%right		EQ_ASSIGN
%left		RIGHT_ASSIGN
%left		'~' TILDE
%left		OR OR2
%left		AND AND2
%left		UNOT NOT
%nonassoc   	GT GE LT LE EQ NE
%left		'+' '-'
%left		'*' '/'
%left		SPECIAL
%left		':'
%left		UMINUS UPLUS
%right		'^'
%left		'$' '@'
%left		NS_GET NS_GET_INT
%nonassoc	'(' '[' LBB

prog	:	END_OF_INPUT			
	|	'\n'				
	|	expr_or_assign '\n'		
	|	expr_or_assign ';'		
	|	error	 			
	;

expr_or_assign  :    expr                     
                |    equal_assign               
                ;

equal_assign    :    expr EQ_ASSIGN expr_or_assign  
                ;

expr	: 	NUM_CONST			
	|	STR_CONST			
	|	NULL_CONST			
	|	SYMBOL				

	|	'{' exprlist '}'		
	|	'(' expr_or_assign ')'		

	|	'-' expr %prec UMINUS		
	|	'+' expr %prec UMINUS		
	|	'!' expr %prec UNOT		
	|	'~' expr %prec TILDE		
	|	'?' expr			

	|	expr ':'  expr			
	|	expr '+'  expr			
	|	expr '-' expr			
	|	expr '*' expr			
	|	expr '/' expr			
	|	expr '^' expr 			
	|	expr SPECIAL expr		
	|	expr '%' expr			
	|	expr '~' expr			
	|	expr '?' expr			
	|	expr LT expr			
	|	expr LE expr			
	|	expr EQ expr			
	|	expr NE expr			
	|	expr GE expr			
	|	expr GT expr			
	|	expr AND expr			
	|	expr OR expr			
	|	expr AND2 expr			
	|	expr OR2 expr			

	|	expr LEFT_ASSIGN expr 		
	|	expr RIGHT_ASSIGN expr 		
	|	FUNCTION '(' formlist ')' cr expr_or_assign %prec LOW
	|	expr '(' sublist ')'		
	|	IF ifcond expr_or_assign 	
	|	IF ifcond expr_or_assign ELSE expr_or_assign	
	|	FOR forcond expr_or_assign %prec FOR 	
	|	WHILE cond expr_or_assign	
	|	REPEAT expr_or_assign		
	|	expr LBB sublist ']' ']'	
	|	expr '[' sublist ']'		
	|	SYMBOL NS_GET SYMBOL		
	|	SYMBOL NS_GET STR_CONST		
	|	STR_CONST NS_GET SYMBOL		
	|	STR_CONST NS_GET STR_CONST	
	|	SYMBOL NS_GET_INT SYMBOL	
	|	SYMBOL NS_GET_INT STR_CONST	
	|	STR_CONST NS_GET_INT SYMBOL	
	|	STR_CONST NS_GET_INT STR_CONST	
	|	expr '$' SYMBOL			
	|	expr '$' STR_CONST		
	|	expr '@' SYMBOL			
	|	expr '@' STR_CONST		
	|	NEXT				
	|	BREAK				
	;


cond	:	'(' expr ')'			
	;

ifcond	:	'(' expr ')'			
	;

forcond :	'(' SYMBOL IN expr ')' 		
	;


exprlist:					
	|	expr_or_assign			
	|	exprlist ';' expr_or_assign	
	|	exprlist ';'			
	|	exprlist '\n' expr_or_assign	
	|	exprlist '\n'			
	;

sublist	:	sub				
	|	sublist cr ',' sub		
	;

sub	:					
	|	expr				
	|	SYMBOL EQ_ASSIGN 		
	|	SYMBOL EQ_ASSIGN expr		
	|	STR_CONST EQ_ASSIGN 		
	|	STR_CONST EQ_ASSIGN expr	
	|	NULL_CONST EQ_ASSIGN 		
	|	NULL_CONST EQ_ASSIGN expr	
	;

formlist:					
	|	SYMBOL				
	|	SYMBOL EQ_ASSIGN expr		
	|	formlist ',' SYMBOL		
	|	formlist ',' SYMBOL EQ_ASSIGN expr 
	;

cr	:	
	;
#endif


/* --------------------------------------------------------------------------
   INTERFACE FROM THE PARSER TO THE LEXICAL ANALYSER
*/


/* Codes for token types.  ASCII codes for single characters also act as
   token numbers.  

   The MAYBE_END type is returned at the end of a line of interactive
   input text from the console, and is treated as end of file if the
   expression could end there, or as nothing otherwise.  Note that end
   of line is not otherwise returned as a token, but instead results
   in newline_before_token being set when the following token is returned. */

enum token_type {
  MAYBE_END=256, END_OF_INPUT,  ERROR,     STR_CONST,        NUM_CONST,
  SYMBOL,        LEFT_ASSIGN,   EQ_ASSIGN, RIGHT_ASSIGN,     NULL_CONST,
  FUNCTION,      LBB,           FOR,       IN,               IF,
  ELSE,          WHILE,         NEXT,      BREAK,            REPEAT,
  GT,            GE,            LT,        LE,               EQ,
  NE,            AND,           OR,        AND2,             OR2,
  NS_GET,        NS_GET_INT,    SPECIAL
};

/* Names for tokens with codes >= 256.  These must correspond in order
   with the codes for token types above.  They are used for error messages. */

static const char *const token_name[] = {
  "end of input","end of input","input",   "string constant","numeric constant",
  "symbol",      "assignment",  "=",       "->",             "'NULL'",
  "'function'",  "'[['",        "'for'",   "'in'",           "'if'",
  "'else'",      "'while'",     "'next'",  "'break'",        "'repeat'",
  "'>'",         "'>='",        "'<'",     "'<='",           "'=='",
  "'!='",        "'&'",         "'|'",     "'&&'",           "'||'",
  "'::'",        "':::'",       "SPECIAL"
};

#define NUM_TRANSLATED 7  /* Number above (at front) that are translated */

#if 0  /* These are just here to trigger the internationalization. */
    _("end of input");
    _("input");
    _("string constant");
    _("numeric constant");
    _("symbol");
    _("assignment");
    _("end of line");  /* currently unused */
#endif


/* The next token from the input, and asociated variables and functions. */

static int next_token;            /* The next token, as an integer code */
static SEXP next_token_val;       /* The value associated with next_token. */
static int newline_before_token;  /* 1 if next token was preceded by '\n' */

static void get_next_token(void); /* Update next_token to the next one */


/* Record of the start and end of part of the source text.  See the
   information in help(srcfile). */

typedef struct
{
  int first_line;
  int first_column;
  int first_byte;

  int last_line;
  int last_column;
  int last_byte;
  
  int first_parsed;
  int last_parsed;
} source_location;

/* Location data for the lookahead token, and one previous to it.  */

static source_location token_loc, prev_token_loc;

/* Internal lexer / parser state. */

static SrcRefState ParseState;


/* --------------------------------------------------------------------------
   INTERFACE FROM THE LEXICAL ANALYSER TO CHARACTER INPUT ROUTINES

   The xxgetc function returns the next character; xxungetc pushes
   a character back to be returned by xxgetc later.  The character
   returned may be SOFT_EOF, indicating the newline at the end of
   a line of interactive console input (which might be the end if
   that is syntactically allowed). 

   The xxgetc function gets a character by calling the function pointed 
   to by ptr_getc, which is set to different functions for different
   input sources. 

   The xxgetc function also maintains the lineno, etc. for source
   references in ParseState, and the context for error reporting in 
   R_ParseContext. */

#include <R_ext/rlocale.h>

#ifdef HAVE_LANGINFO_CODESET
# include <langinfo.h>
#endif

static int xxgetc();
static void xxungetc(int);

#define SOFT_EOF (EOF == -1 ? -2 : -1)  /* NL on interactive input */

static int (*ptr_getc)(void);     /* Function to call to get a character */

/* Private pushback, since file ungetc only guarantees one byte.
   We need up to one MBCS-worth */

#define PUSHBACK_BUFSIZE 16
static int pushback[PUSHBACK_BUFSIZE];
static unsigned int npush = 0;

static int prevpos = 0;
static int prevlines[PUSHBACK_BUFSIZE];
static int prevcols[PUSHBACK_BUFSIZE];
static int prevbytes[PUSHBACK_BUFSIZE];
static int prevparse[PUSHBACK_BUFSIZE];


/* --------------------------------------------------------------------------
   CHARACTER INPUT ROUTINES
*/

static void ParseInit(void)
{
    npush = 0;
    R_ParseContextLast = 0;
    R_ParseContext[0] = '\0';
}

static int xxgetc(void)
{
    int c, oldpos;

    c = npush > 0 ? pushback[--npush] : ptr_getc();

    oldpos = prevpos;
    prevpos = (prevpos + 1) % PUSHBACK_BUFSIZE;
    prevbytes[prevpos] = ParseState.xxbyteno;
    prevlines[prevpos] = ParseState.xxlineno;  
    prevparse[prevpos] = ParseState.xxparseno;

    /* We only advance the column for the 1st byte in UTF-8, so handle later 
       bytes specially */

    if (0x80 <= (unsigned char) c && (unsigned char) c <= 0xBF 
                                  && known_to_be_utf8) {
    	ParseState.xxcolno--;   
    	prevcols[prevpos] = prevcols[oldpos];
    } else 
    	prevcols[prevpos] = ParseState.xxcolno;
    	
    if (c == EOF)
	return R_EOF;

    R_ParseContextLast = (R_ParseContextLast + 1) % PARSE_CONTEXT_SIZE;
    R_ParseContext[R_ParseContextLast] = c == SOFT_EOF ? '\n' : c;

    if (c == '\n') {
	ParseState.xxlineno += 1;
	ParseState.xxcolno = 0;
    	ParseState.xxbyteno = 0;
    	ParseState.xxparseno += 1;
    } else {
        ParseState.xxcolno += 1;
    	ParseState.xxbyteno += 1;
    }

    if (c == '\t') ParseState.xxcolno = ((ParseState.xxcolno + 7) & ~7);
    
    R_ParseContextLine = ParseState.xxlineno;    
    return c;
}

static void xxungetc(int c)
{
    /* This assumes that c was the result of xxgetc; if not, some edits will 
       be needed */

    ParseState.xxlineno = prevlines[prevpos];
    ParseState.xxbyteno = prevbytes[prevpos];
    ParseState.xxcolno  = prevcols[prevpos];
    ParseState.xxparseno = prevparse[prevpos];
    
    prevpos = (prevpos + PUSHBACK_BUFSIZE - 1) % PUSHBACK_BUFSIZE;

    R_ParseContextLine = ParseState.xxlineno;

    R_ParseContext[R_ParseContextLast] = '\0';
    /* precaution as to how % is implemented for < 0 numbers */
    R_ParseContextLast 
      = (R_ParseContextLast + PARSE_CONTEXT_SIZE - 1) % PARSE_CONTEXT_SIZE;
    if(npush >= PUSHBACK_BUFSIZE) abort();
    pushback[npush++] = c;
}


/* --------------------------------------------------------------------------
   SOURCE REFERENCE ROUTINES
*/

static SEXP makeSrcref(source_location *lloc, SEXP srcfile)
{
    SEXP val;

    PROTECT(val = allocVector(INTSXP, 8));
    INTEGER(val)[0] = lloc->first_line;
    INTEGER(val)[1] = lloc->first_byte;
    INTEGER(val)[2] = lloc->last_line;
    INTEGER(val)[3] = lloc->last_byte;
    INTEGER(val)[4] = lloc->first_column;
    INTEGER(val)[5] = lloc->last_column;
    INTEGER(val)[6] = lloc->first_parsed;
    INTEGER(val)[7] = lloc->last_parsed;
    setAttrib(val, R_SrcfileSymbol, srcfile);
    setAttrib(val, R_ClassSymbol, mkString("srcref"));
    UNPROTECT(1);
    return val;
}

static void attachSrcrefs(SEXP val, SEXP t)
{
    SEXP srval;
    int n;

    PROTECT(val);
    PROTECT(srval = allocVector(VECSXP, length(t)));
    for (n = 0 ; n < LENGTH(srval) ; n++, t = CDR(t))
	SET_VECTOR_ELT(srval, n, CAR(t));
    setAttrib(val, R_SrcrefSymbol, srval);
    setAttrib(val, R_SrcfileSymbol, ParseState.SrcFile);
    {
	source_location wholeFile;
	wholeFile.first_line = 1;
	wholeFile.first_byte = 0;
	wholeFile.first_column = 0;
	wholeFile.last_line = ParseState.xxlineno;
	wholeFile.last_byte = ParseState.xxbyteno;
	wholeFile.last_column = ParseState.xxcolno;
	wholeFile.first_parsed = 1;
	wholeFile.last_parsed = ParseState.xxparseno;
	setAttrib(val, R_WholeSrcrefSymbol, 
                       makeSrcref(&wholeFile, ParseState.SrcFile));
    }
    UNPROTECT(2);

    ParseState.didAttach = TRUE;
}

void R_InitSrcRefState(SrcRefState *state)
{
    state->keepSrcRefs = FALSE;
    state->didAttach = FALSE;
    PROTECT_WITH_INDEX(state->SrcFile = R_NilValue, &(state->SrcFileProt));
    PROTECT_WITH_INDEX(state->Original = R_NilValue, &(state->OriginalProt));
    state->xxlineno = 1;
    state->xxcolno = 0;
    state->xxbyteno = 0;
    state->xxparseno = 1;
    token_loc.first_line = 0;
    token_loc.first_column = 0;
    token_loc.first_byte = 0;
    token_loc.first_parsed = 1;
}

void R_FinalizeSrcRefState(SrcRefState *state)
{
    UNPROTECT(1);
    if (R_PPStackTop != state->OriginalProt) abort();
    UNPROTECT(1);
    if (R_PPStackTop != state->SrcFileProt) abort();
}

static void UseSrcRefState(SrcRefState *state)
{
    if (state) {
	ParseState.keepSrcRefs = state->keepSrcRefs;
	ParseState.SrcFile = state->SrcFile;
	ParseState.Original = state->Original;
	ParseState.SrcFileProt = state->SrcFileProt;
	ParseState.xxlineno = state->xxlineno;
	ParseState.xxcolno = state->xxcolno;
	ParseState.xxbyteno = state->xxbyteno;
	ParseState.xxparseno = state->xxparseno;
    } else 
    	R_InitSrcRefState(&ParseState);
}

static void PutSrcRefState(SrcRefState *state)
{
    if (state) {
	state->keepSrcRefs = ParseState.keepSrcRefs;
	state->SrcFile = ParseState.SrcFile;
	state->Original = ParseState.Original;
	state->SrcFileProt = ParseState.SrcFileProt;
	state->xxlineno = ParseState.xxlineno;
	state->xxcolno = ParseState.xxcolno;
	state->xxbyteno = ParseState.xxbyteno;
	state->xxparseno = ParseState.xxparseno;
    } else 
    	R_FinalizeSrcRefState(&ParseState);
}


/* --------------------------------------------------------------------------
   VARIABLES, MACROS, AND FUNCTIONS SUPPORTING THE PARSER
*/

/* Begin a recursive-descent parsing routine.  Sets up for PROTECT_N. */

#define BGN_PARSE_FUN \
    int nprotect = 0


/* End a recursive-descent parsing routine.  Unprotects everything that
   was protected with PROTECT_N.  Allows for exitting with NULL result
   on an error. */

#define END_PARSE_FUN \
  end: \
    UNPROTECT(nprotect); \
    goto finish; \
  error: \
    UNPROTECT(nprotect); \
    return NULL; \
  finish:


/* Parse a sub-expression (or other construct), with the call given as
   its argument.  Protects the result, which will normally be assigned
   to a local variable (in the argument).  If the sub-expression parse
   produced an error, this parse routine is exitted as well. */

#define PARSE_SUB(w) \
    do { \
        SEXP _sub_ = (w); \
        if (_sub_ == NULL) goto error; \
        PROTECT_N(_sub_); \
    } while (0)


/* Produce an error message and exit parsing (up to the top level). */

#define PARSE_ERROR_MSG(s) \
    do { \
        error_msg(s); \
        goto error; \
    } while (0)

static void error_msg(const char *s)
{
    static char const unexpected[] = "syntax error, unexpected ";

    R_ParseError     = token_loc.first_line;
    R_ParseErrorCol  = token_loc.first_column;
    R_ParseErrorFile = ParseState.SrcFile;

    if (strcmp(s,unexpected) == 0) {
        if (next_token < 256) {
            char t[4] = { '\'', next_token, '\'', 0 };
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, t);
        }
        else if (next_token-256 < NUM_TRANSLATED)
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, 
                           _(token_name[next_token-256]));
        else
            copy_2_strings(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s, 
                           token_name[next_token-256]);
    }
    else
        copy_1_string(R_ParseErrorMsg, sizeof R_ParseErrorMsg, s);

    R_ParseErrorMsg [(sizeof R_ParseErrorMsg) - 1] = 0; /* just in case */
}


/* Produce an error message saying the current token is unexpected, and
   exit to top level.  The token name is filled in by error_msg, based
   on the current value of next_token. */

#define PARSE_UNEXPECTED() PARSE_ERROR_MSG("syntax error, unexpected ");


/* Say the current is unexpected unless it is equal to tk. */

#define EXPECT(tk) \
    do { \
        if (next_token != (tk)) \
            PARSE_UNEXPECTED(); \
        get_next_token(); \
    } while (0)


/* Protect a SEXP used in a parse routine from garbage collection. */

#define PROTECT_N(w) (nprotect++, PROTECT(w))


/* Look at the next token, which will usually already be in next_token.
   However, if next_token is MAYBE_END, advance to the next real token
   first. */

#define NEXT_TOKEN \
  (next_token == MAYBE_END ? get_next_token_not_maybe_end() : next_token) 

static int get_next_token_not_maybe_end(void)
{
    do { 
        get_next_token(); 
    } while (next_token == MAYBE_END);

    return next_token;
}


/* Get the SEXP value associated with next_token, protecting it. */

#define TOKEN_VALUE() (PROTECT_N(next_token_val))


/* Check whether the current expression is ended by a newline, based on
   the 'flags' and 'newline_before_token' variables. */

#define NL_END ((flags & END_ON_NL) && newline_before_token)


/* Save the start location of next_token as the start of a region of
   the source text. */

static void start_location (source_location *loc)
{
    loc->first_line   = loc->last_line   = token_loc.first_line;
    loc->first_column = loc->last_column = token_loc.first_column;
    loc->first_byte   = loc->last_byte   = token_loc.first_byte;
    loc->first_parsed = loc->last_parsed = token_loc.first_parsed;
}


/* Save the end location of the previous token as the end of a region
   of source text. */

static void end_location (source_location *loc)
{
    loc->last_line   = prev_token_loc.last_line;
    loc->last_column = prev_token_loc.last_column;
    loc->last_byte   = prev_token_loc.last_byte;
    loc->last_parsed = prev_token_loc.last_parsed;
}


/* --------------------------------------------------------------------------
   THE RECURSIVE DESCENT PARSER

   Each parse routine takes an int flags argument, and a pointer to an
   int in which to return a status.  

   The parse routines return the object parsed, or NULL if there was an
   error (or errors may cause exit out of the whole parser with a call
   of "error").

   Parsing routines are called with next_token already set to the first
   token of the construct they parse, and return with next_token set to
   the token after the construct they parsed.  Note, however, that this
   token may be MAYBE_END, which is a "soft" end-of-file that is replaced
   by an actual token if the token is accessed via NEXT_TOKEN rather than
   next_token. 

   Source references are attached if keep_source is non-zero. */


int keep_source;  /* Attach source references to R expressions? */

static SEXP parse_expr (int flags, int *stat), 
            parse_expr_or_assign (int flags, int *stat);


/* Bits in the flags word passed to parsing routines. */

#define KEEP_PARENS (1<<0)  /* Keep parens in this or inner expressions */
#define END_ON_NL   (1<<1)  /* End expression when newline seen */


/* Parse the formals list of a function definiton. */

static SEXP parse_formlist (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res;

    flags &= ~END_ON_NL;
    res = R_NilValue;
    if (NEXT_TOKEN != ')') {
        SEXP last;
        res = PROTECT_N (CONS(R_MissingArg,R_NilValue));
        last = res;
        for (;;) {
            SEXP tag, f;
            if (NEXT_TOKEN != SYMBOL)
                PARSE_UNEXPECTED();
            tag = TOKEN_VALUE();
            for (f = res; f != R_NilValue; f = CDR(f)) {
                if (TAG(f) == tag) {
                    source_location loc;
                    start_location(&loc);
                    error(_("Repeated formal argument '%s' on line %d"), 
                            CHAR(PRINTNAME(tag)), loc.first_line);
                }
            }
            SET_TAG (last, tag);
            get_next_token();
            if (NEXT_TOKEN == EQ_ASSIGN) {
                SEXP def;
                get_next_token();
                PARSE_SUB(def = parse_expr(flags,stat));
                SETCAR (last, def);
            }
            if (NEXT_TOKEN != ',')
                break;
            get_next_token();
            SETCDR (last, CONS(R_MissingArg,R_NilValue));
            last = CDR(last);
        }
    }

    END_PARSE_FUN;
    return res;
}

/* Parse a list of subscripts or of function arguments.  An attempt is 
   made to make the last part of the list be a constant object.  Note
   that NULL is allowed as a tag (converted to `NULL`), presumably for 
   compatibility, though it's not allowed for a formal name.  Strings
   are also allowed for tags, though again they aren't for formal names. */

static SEXP parse_sublist (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, last, last2;

    flags &= ~END_ON_NL;
    res = R_NilValue;
    if (NEXT_TOKEN != ')') { /* check only ')', not ']':  [] has missing arg */
        SEXP next;
        for (;;) {
            SEXP arg;
            if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' || NEXT_TOKEN == ']')
                next = MaybeConstList1(R_MissingArg);
            else {
                PARSE_SUB(arg = parse_expr(flags,stat));
                if (NEXT_TOKEN == EQ_ASSIGN) {
                    SEXP tag, val;
                    if (TYPEOF(arg) == SYMSXP)
                        tag = arg;
                    else if (TYPEOF(arg) == STRSXP)
                        tag = install (translateChar (STRING_ELT(arg,0)));
                    else if (arg == R_NilValue)
                        tag = install("NULL");
                    else
                        PARSE_UNEXPECTED();
                    get_next_token();
                    if (NEXT_TOKEN == ',' || NEXT_TOKEN == ')' 
                                          || NEXT_TOKEN == ']')
                        val = R_MissingArg;
                    else
                        PARSE_SUB(val = parse_expr(flags,stat));
                    next = cons_with_tag(val,R_NilValue,tag);
                }
                else {
                    next = MaybeConstList1(arg);
                }
            }
            if (res == R_NilValue) {
                PROTECT_N (res = next);
                last = res;
                last2 = R_NilValue;
            }
            else {
                if (IS_CONSTANT(last)) {
                    last = cons_with_tag(CAR(last),CDR(last),TAG(last));
                    if (last2 == R_NilValue)
                        PROTECT_N (res = last);
                    else
                        SETCDR(last2,last);
                }
                SETCDR(last,next);
                last2 = last;
                last = next;
            }
            if (NEXT_TOKEN != ',')
                break;
            get_next_token();
        }
    }

    END_PARSE_FUN;
    return res;
}

/* Parse an element that acts as a unit for the operator precedence.
   Such an element consists of an initial part followed by possible postfix
   parts.  The initial part may be a constant, symbol, paren expression,
   or curly expression, which may be followed by postfix parts, or a function 
   closure, while, repeat, for, or if, which would absorb any postfix parts
   themselves, or break, or next, which can be followed by postfix parts
   although they make no sense.  Postfix parts may be argument lists for
   function calls, or subsetting operators [, [[, $, or @.

   Curly expressions and function closures may have source references. */

static SEXP parse_element (int flags, int *stat)
{
    BGN_PARSE_FUN;
    source_location loc;
    SEXP res;

    /* Symbols, string constants, and namespace references built from
       one or the other or both of these. */

    if (NEXT_TOKEN == SYMBOL || NEXT_TOKEN == STR_CONST) {
        SEXP op, sym;
        res = TOKEN_VALUE();
        get_next_token();
        if (!NL_END && (NEXT_TOKEN == NS_GET || NEXT_TOKEN == NS_GET_INT)) {
            op = TOKEN_VALUE();
            get_next_token();
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = PROTECT_N (LCONS (op, CONS (res, MaybeConstList1(sym))));
            get_next_token();
        }
    }

    /* Numeric, logical, and NULL constants. */

    else if (NEXT_TOKEN == NUM_CONST || NEXT_TOKEN == NULL_CONST) {
        res = TOKEN_VALUE();
        get_next_token();
    }

    /* Paren expressions. */

    else if (NEXT_TOKEN == '(') {
        SEXP op;
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_expr_or_assign(flags&~END_ON_NL,stat));
        if (flags & KEEP_PARENS)
            res = PROTECT_N (LCONS (op, MaybeConstList1(res)));
        EXPECT(')');
    }

    /* Curly expressions. */

    else if (NEXT_TOKEN == '{') {
        SEXP next, last, op, refs, last_ref;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS(op,R_NilValue));
        start_location(&loc);
        get_next_token();
        end_location(&loc);
        if (keep_source) {
            PROTECT_N (refs = CONS (makeSrcref(&loc,ParseState.SrcFile),
                                    R_NilValue));
            last_ref = refs;
        }
        last = res;
        for (;;) {
            while (NEXT_TOKEN == ';' || NEXT_TOKEN == '\n')
                get_next_token();
            if (NEXT_TOKEN == '}')
                break;
            start_location(&loc);
            PARSE_SUB (next = parse_expr_or_assign(flags|END_ON_NL,stat));
            end_location(&loc);
            if (keep_source) {
                SETCDR (last_ref, CONS (makeSrcref(&loc,ParseState.SrcFile),
                                        R_NilValue));
                last_ref = CDR(last_ref);
            }
            SETCDR (last, CONS(next,R_NilValue));
            last = CDR(last);
        }
        if (keep_source) {
            attachSrcrefs(res,refs);
        }
        get_next_token();
    }

    /* Function closures. */

    else if (NEXT_TOKEN == FUNCTION) {
        SEXP op, args, body, srcref;
        start_location(&loc);
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(args = parse_formlist(flags,stat));
        EXPECT(')');
        PARSE_SUB(body = parse_expr_or_assign(flags,stat));
        end_location(&loc);
        if (keep_source) {
            srcref = makeSrcref(&loc, ParseState.SrcFile);
            ParseState.didAttach = TRUE;
        } 
        else
            srcref = R_NilValue;
        res = PROTECT_N (lang4 (op, args, body, srcref));
    }

    /* Repeat statements. */

    else if (NEXT_TOKEN == REPEAT) {
        SEXP op, body;
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB(body = parse_expr_or_assign(flags,stat));
        res = PROTECT_N (lang2 (op, body));
    }

    /* While statements. */

    else if (NEXT_TOKEN == WHILE) {
        SEXP op, cond, body;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(cond = parse_expr(flags&~END_ON_NL,stat));
        EXPECT(')');
        PARSE_SUB(body = parse_expr_or_assign(flags,stat));
        res = PROTECT_N (lang3 (op, cond, body));
    }

    /* If statements. */

    else if (NEXT_TOKEN == IF) {

        SEXP op, cond, true_stmt, false_stmt;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        PARSE_SUB(cond = parse_expr(flags&~END_ON_NL,stat));
        EXPECT(')');
        PARSE_SUB(true_stmt = parse_expr_or_assign(flags,stat));

        if (!NL_END && NEXT_TOKEN == ELSE) {
            get_next_token();
            PARSE_SUB(false_stmt = parse_expr_or_assign(flags,stat));
            res = PROTECT_N (LCONS (op, CONS (cond, CONS (true_stmt,
                              MaybeConstList1(false_stmt)))));
        }
        else
            res = PROTECT_N (LCONS (op, CONS (cond,
                              MaybeConstList1(true_stmt))));
    }

    /* For statements. */

    else if (NEXT_TOKEN == FOR) {
        SEXP op, sym, vec, body;
        op = TOKEN_VALUE();
        get_next_token();
        EXPECT('(');
        if (NEXT_TOKEN != SYMBOL)
            PARSE_UNEXPECTED();
        sym = TOKEN_VALUE();
        get_next_token();
        EXPECT(IN);
        PARSE_SUB(vec = parse_expr(flags&~END_ON_NL,stat));
        EXPECT(')');
        PARSE_SUB(body = parse_expr_or_assign(flags,stat));
        res = PROTECT_N (lang4 (op, sym, vec, body));
    }

    /* Next and break statements. */

    else if (NEXT_TOKEN == NEXT || NEXT_TOKEN == BREAK) {
        SEXP op;
        op = TOKEN_VALUE();
        res = PROTECT_N (LCONS (op, R_NilValue));
        get_next_token();
    }

    else
        PARSE_UNEXPECTED();

    /* Now parse any postfix parts, unless we are ending due to a newline. */

    while (!NL_END) {

        /* Function call. */

        if (NEXT_TOKEN == '(') {
            SEXP subs;
            get_next_token();
            PARSE_SUB(subs = parse_sublist(flags,stat));
            if (isString(res))
                res = installChar(STRING_ELT(res,0));
            res = LCONS(res,subs);
            EXPECT(')');
        }

        /* Subscripting with [. */

        else if (NEXT_TOKEN == '[') {
            SEXP op, subs;
            op = TOKEN_VALUE();
            get_next_token();
            PARSE_SUB(subs = parse_sublist(flags,stat));
            res = LCONS (op, CONS (res, subs));
            EXPECT(']');
        }

        /* Subscripting with [[.  Note that it may be terminated with ] ]. */

        else if (NEXT_TOKEN == LBB) {
            SEXP op, subs;
            op = TOKEN_VALUE();
            get_next_token();
            PARSE_SUB(subs = parse_sublist(flags,stat));
            res = LCONS (op, CONS (res, subs));
            EXPECT(']');
            EXPECT(']');
        }

        /* Subsetting with $ or @. */

        else if (NEXT_TOKEN == '$' || NEXT_TOKEN == '@') {
            SEXP op, sym;
            op = TOKEN_VALUE();
            get_next_token();
            if (NEXT_TOKEN != SYMBOL && NEXT_TOKEN != STR_CONST)
                PARSE_UNEXPECTED();
            sym = TOKEN_VALUE();
            res = LCONS (op, CONS (res, MaybeConstList1(sym)));
            get_next_token();
        }

        else
            break;
    }

    END_PARSE_FUN;
    return res;
}

/* Binary and unary operators, arranged in recursive hierarchy by precedence.
   Highest precedence is first below. */

static SEXP parse_power (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_element(flags,stat));

    if (!NL_END && NEXT_TOKEN == '^') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_power(flags,stat));
        res = LCONS (op, CONS (res, MaybeConstList1(right)));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_unary_plus_minus (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, op;

    if (NEXT_TOKEN == '+' || NEXT_TOKEN == '-') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_unary_plus_minus(flags,stat));
        res = LCONS (op, MaybeConstList1(res));
    }
    else
        PARSE_SUB (res = parse_power(flags,stat));

    END_PARSE_FUN;
    return res;
}

static SEXP parse_colon (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_unary_plus_minus(flags,stat));

    while (!NL_END && NEXT_TOKEN == ':') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_unary_plus_minus(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_special (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_colon(flags,stat));

    while (!NL_END && NEXT_TOKEN == SPECIAL) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_colon(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_mul_div (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_special(flags,stat));

    while (!NL_END && (NEXT_TOKEN == '*' || NEXT_TOKEN == '/')) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_special(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_plus_minus (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_mul_div(flags,stat));

    while (!NL_END && (NEXT_TOKEN == '+' || NEXT_TOKEN == '-')) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_mul_div(flags,stat));
        PROTECT_N (res = res ? LCONS (op, CONS (res, MaybeConstList1(right)))
                             : LCONS (op, MaybeConstList1(right)));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_relation (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_plus_minus(flags,stat));

    if (!NL_END && (NEXT_TOKEN == GT || NEXT_TOKEN == GE || NEXT_TOKEN == EQ
                 || NEXT_TOKEN == LE || NEXT_TOKEN == LT || NEXT_TOKEN == NE)) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_plus_minus(flags,stat));
        res = LCONS (op, CONS (res, MaybeConstList1(right)));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_not (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, op;

    if (NEXT_TOKEN == '!') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_not(flags,stat));
        res = LCONS (op, MaybeConstList1(res));
    }
    else
        PARSE_SUB (res = parse_relation(flags,stat));

    END_PARSE_FUN;
    return res;
}

static SEXP parse_and (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_not(flags,stat));

    while (!NL_END && (NEXT_TOKEN == AND || NEXT_TOKEN == AND2)) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_not(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_or (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_and(flags,stat));

    while (!NL_END && (NEXT_TOKEN == OR || NEXT_TOKEN == OR2)) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_and(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_unary_tilde (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, op;

    if (NEXT_TOKEN == '~') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_unary_tilde(flags|KEEP_PARENS,stat));
        res = LCONS (op, MaybeConstList1(res));
    }
    else
        PARSE_SUB (res = parse_or(flags,stat));

    END_PARSE_FUN;
    return res;
}

static SEXP parse_tilde (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_unary_tilde(flags,stat));

    while (!NL_END && NEXT_TOKEN == '~') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_unary_tilde(flags|KEEP_PARENS,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_right_assign (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_tilde(flags,stat));

    while (!NL_END && NEXT_TOKEN == RIGHT_ASSIGN) {
        op = TOKEN_VALUE();  /* already switched to left assignment */
        get_next_token();
        PARSE_SUB (right = parse_tilde(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (right, MaybeConstList1(res))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_left_assign (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_right_assign(flags,stat));

    if (!NL_END && NEXT_TOKEN == LEFT_ASSIGN) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_left_assign(flags,stat));
        res = LCONS (op, CONS (res, MaybeConstList1(right)));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_unary_query (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, op;

    if (NEXT_TOKEN == '?') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (res = parse_unary_query(flags,stat));
        res = LCONS (op, MaybeConstList1(res));
    }
    else
        PARSE_SUB (res = parse_left_assign(flags,stat));

    END_PARSE_FUN;
    return res;
}

static SEXP parse_expr (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_unary_query(flags,stat));

    while (!NL_END && NEXT_TOKEN == '?') {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_unary_query(flags,stat));
        PROTECT_N (res = LCONS (op, CONS (res, MaybeConstList1(right))));
    }

    END_PARSE_FUN;
    return res;
}

static SEXP parse_expr_or_assign (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res, right, op;

    PARSE_SUB (res = parse_expr(flags,stat));

    if (!NL_END && NEXT_TOKEN == EQ_ASSIGN) {
        op = TOKEN_VALUE();
        get_next_token();
        PARSE_SUB (right = parse_expr_or_assign(flags,stat));
        res = LCONS (op, CONS (res, MaybeConstList1(right)));
    }

    END_PARSE_FUN;
    return res;
}

/* Top level parse function, parsing an expression or assignments with =,
   which is followed by newline or ';' or end of file. */

static SEXP parse_prog (int flags, int *stat)
{
    BGN_PARSE_FUN;
    SEXP res;

    PARSE_SUB (res = parse_expr_or_assign(flags,stat));

    /* By first checking newline_before_token, we avoid forcing MAYBE_END
       to be replaced by an actual token when taking interactive input. */
       
    if (newline_before_token || NEXT_TOKEN == END_OF_INPUT)
        ; /* OK */
    else if (NEXT_TOKEN == ';')
        get_next_token();
    else
        PARSE_UNEXPECTED();

    END_PARSE_FUN;
    return res;
}

/* -------------------------------------------------------------------------- */

/* R_Parse1 is a glue function between the recursive descent parsing routines
   and the parsing entry points.  It sets R_CurrentExpr to the expresion
   parsed (as with the old parsing routines), but it probably shouldn't. 

   The keep_source variable should be set before calling this function. */

static SEXP R_Parse1(ParseStatus *status, source_location *loc)
{
    SEXP res;
    int stat;

    if (NEXT_TOKEN == END_OF_INPUT) {
        *status = PARSE_EOF;
        return R_CurrentExpr = R_NilValue;
    }

    if (NEXT_TOKEN == ';') {
        get_next_token();
        *status = PARSE_NULL;
        return R_CurrentExpr = R_NilValue;
    }

    start_location(loc);
    res = parse_prog (END_ON_NL, &stat);
    end_location(loc);

    if (res == NULL) {
        *status = next_token == END_OF_INPUT ? PARSE_INCOMPLETE : PARSE_ERROR;
        return R_CurrentExpr = R_NilValue;
    }

    *status = PARSE_OK;
    return R_CurrentExpr = res;
}

/* -------------------------------------------------------------------------- 
   PARSING ENTRY POINTS.

   See the documentation at the start of this module. */


static FILE *fp_parse;

extern int R_fgetc(FILE*);

static int file_getc(void)
{
    int c;
    c = R_fgetc(fp_parse);
    return c == '\n' ? SOFT_EOF : c;
}

/* used in main.c */
attribute_hidden
SEXP R_Parse1File(FILE *fp, int gencode, ParseStatus *status, SrcRefState *state)
{
REprintf("In R_Parse1File\n");
    source_location loc;
    SEXP res;

    UseSrcRefState(state);
    ParseInit();
    fp_parse = fp;
    ptr_getc = file_getc;

    keep_source = gencode && state->keepSrcRefs;
    get_next_token();
    res = R_Parse1(status,&loc);
REprintf("R_Parse1 has returned %d\n",*status);

    PutSrcRefState(state);
    return gencode ? res : R_NilValue;
}


static IoBuffer *iob;

static int buffer_getc(void)
{
    return R_IoBufferGetc(iob);
}

/* Used only in main.c */
attribute_hidden
SEXP R_Parse1Buffer(IoBuffer *buffer, int gencode, ParseStatus *status)
{
    Rboolean keepSource = FALSE; 
    source_location loc;
    SEXP res;

    R_InitSrcRefState(&ParseState);
    if (gencode) {
    	keepSource = asLogical(GetOption1(install("keep.source")));
    	if (keepSource) {
    	    ParseState.keepSrcRefs = TRUE;
    	    REPROTECT(ParseState.SrcFile = 
                        NewEnvironment(R_NilValue, R_NilValue, R_EmptyEnv),
                        ParseState.SrcFileProt);
	    REPROTECT(ParseState.Original = ParseState.SrcFile, 
                        ParseState.OriginalProt);
	}
    }

    ParseInit();
    iob = buffer;
    ptr_getc = buffer_getc;

    keep_source = gencode && ParseState.keepSrcRefs;
    get_next_token();
    res = R_Parse1(status,&loc);
    if (!gencode) res = R_NilValue;

    if (gencode && keepSource) {
    	if (ParseState.didAttach) {
            SEXP filename_install = install("filename");  /* protected by the */
            SEXP lines_install = install("lines");        /*   symbol table   */
   	    int buflen = R_IoBufferReadOffset(buffer);
   	    char buf[buflen+1];
   	    SEXP class;
   	    R_IoBufferReadReset(buffer);
   	    for (int i=0; i<buflen; i++)
   	    	buf[i] = R_IoBufferGetc(buffer);

   	    buf[buflen] = 0;
    	    defineVar (filename_install, ScalarString(mkChar("")), 
                       ParseState.Original);
    	    defineVar (lines_install, ScalarString(mkChar(buf)),
                       ParseState.Original);
    	    PROTECT(class = allocVector(STRSXP, 2));
            SET_STRING_ELT(class, 0, mkChar("srcfilecopy"));
            SET_STRING_ELT(class, 1, mkChar("srcfile"));
	    setAttrib(ParseState.Original, R_ClassSymbol, class);
	    UNPROTECT(1);
	}
    }

    R_FinalizeSrcRefState(&ParseState);
    return res;
}


static SEXP R_Parse(int n, ParseStatus *status, SEXP srcfile)
{
    SEXP rval, tval, tlast, cur, refs, last_ref;
    source_location loc;
    int i;

    R_InitSrcRefState(&ParseState);
    
    ParseInit();

    REPROTECT(ParseState.SrcFile = srcfile, ParseState.SrcFileProt);
    REPROTECT(ParseState.Original = srcfile, ParseState.OriginalProt);

    PROTECT(tval = CONS(R_NilValue,R_NilValue));
    tlast = tval;

    if (!isNull(ParseState.SrcFile)) {
    	ParseState.keepSrcRefs = TRUE;
        PROTECT(refs = CONS(R_NilValue,R_NilValue));
        last_ref = refs;
    }
    else
        PROTECT(refs = R_NilValue);
    
    keep_source = ParseState.keepSrcRefs;
    get_next_token();

    for(i = 0; ; ) {
	if(n >= 0 && i >= n) break;

	cur = R_Parse1(status,&loc);

	switch(*status) {
	case PARSE_NULL:
	    break;
	case PARSE_OK:
            SETCDR (tlast, CONS (cur, R_NilValue));
            tlast = CDR(tlast);
            if (ParseState.keepSrcRefs) {
                SETCDR (last_ref, 
                        CONS (makeSrcref(&loc,ParseState.SrcFile), R_NilValue));
                last_ref = CDR(last_ref);
            }
	    i++;
	    break;
	case PARSE_INCOMPLETE:
	case PARSE_ERROR:
	    UNPROTECT(2); /* tval, refs */
	    R_FinalizeSrcRefState(&ParseState);
	    return R_NilValue;
	case PARSE_EOF:
	    goto finish;
	}
    }

finish:
    tval = CDR(tval);
    PROTECT(rval = allocVector(EXPRSXP, length(tval)));
    for (i = 0 ; i < LENGTH(rval) ; i++, tval = CDR(tval))
	SET_VECTOR_ELT(rval, i, CAR(tval));
    if (ParseState.keepSrcRefs)
	attachSrcrefs(rval,CDR(refs));

    UNPROTECT(3); /* tval, refs, rval */
    R_FinalizeSrcRefState(&ParseState);
    *status = PARSE_OK;
    return rval;
}


/* used in edit.c */
attribute_hidden
SEXP R_ParseFile(FILE *fp, int n, ParseStatus *status, SEXP srcfile)
{
    fp_parse = fp;
    ptr_getc = file_getc;

    return R_Parse(n, status, srcfile);
}


#include "Rconnections.h"

static Rconnection conn_parse;

static int conn_getc(void)
{
    return Rconn_fgetc(conn_parse);
}
 
/* used in source.c */
attribute_hidden
SEXP R_ParseConn(Rconnection con, int n, ParseStatus *status, SEXP srcfile)
{
    conn_parse = con;
    ptr_getc = conn_getc;

    return R_Parse(n, status, srcfile);
}


static TextBuffer *txtb;

static int text_getc(void)
{
    int c = R_TextBufferGetc(txtb);
    return c;
}

/* This one is public, and used in source.c */
SEXP R_ParseVector(SEXP text, int n, ParseStatus *status, SEXP srcfile)
{
    SEXP rval;
    TextBuffer textb;
    R_TextBufferInit(&textb, text);
    txtb = &textb;
    ptr_getc = text_getc;

    rval = R_Parse(n, status, srcfile);

    R_TextBufferFree(&textb);
    return rval;
}


static int need_console_read;
static const char *prompt_string;

static int console_getc(void)
{
    char *bufp, console_buf[CONSOLE_BUFFER_SIZE];
    char c;

    if (need_console_read) {
        if (R_ReadConsole (prompt_string, (unsigned char *) console_buf, 
                           CONSOLE_BUFFER_SIZE, 1) == 0)
            return EOF;
        for (bufp = console_buf; *bufp; bufp++) R_IoBufferPutc(*bufp, iob);
        need_console_read = 0;
    }
    c = R_IoBufferGetc(iob);
    if (c == EOF) {
        need_console_read = 1;
        return SOFT_EOF;
    }
    return c;
}

/* used in source.c */
attribute_hidden
SEXP R_ParseBuffer(IoBuffer *buffer, int n, ParseStatus *status, SEXP prompt, 
		   SEXP srcfile)
{
    SEXP rval, tval, tlast, cur, refs, last_ref;
    int c, i;
    source_location loc;

    prompt_string = isString(prompt) && LENGTH(prompt) > 0
                     ? CHAR(STRING_ELT(prompt,0)) 
                     : CHAR(STRING_ELT(GetOption1(install("prompt")),0));

    R_IoBufferWriteReset(buffer);
    need_console_read = 1;

    iob = buffer;
    ptr_getc = console_getc;

    rval = R_Parse (n, status, srcfile);

    R_IoBufferWriteReset(buffer);
    return rval;
}


/* --------------------------------------------------------------------------
   TEXT BUFFER

   This is used as the buffer for NumericValue, SpecialValue and
   SymbolValue.  None of these could conceivably need 8192 bytes.

   It has not been used as the buffer for input character strings
   since Oct 2007 (released as 2.7.0), and for comments since 2.8.0. */

static char yytext[MAXELTSIZE];

#define DECLARE_YYTEXT_BUFP(bp) char *bp = yytext

#define YYTEXT_PUSH(c, bp) do { \
    if ((bp) - yytext >= sizeof(yytext) - 1) \
        error(_("input buffer overflow at line %d"), ParseState.xxlineno); \
    *(bp)++ = (c); \
} while(0)


/* --------------------------------------------------------------------------
   ROUTINES FOR CREATING NUMERIC AND STRING VALUES
*/


static SEXP mkReal(const char *s)
{
    return ScalarRealMaybeConst(R_atof(s));
}


static SEXP mkInteger(const char *s)
{
    double f = R_atof(s);  /* or R_strtol? */
    return ScalarIntegerMaybeConst((int) f);
}


static SEXP mkComplex(const char *s)
{
    SEXP t = R_NilValue;
    double f;
    f = R_atof(s); /* FIXME: make certain the value is legitimate. */

    t = allocVector(CPLXSXP, 1);
    COMPLEX(t)[0].r = 0;
    COMPLEX(t)[0].i = f;

    return t;
}


static int NumericValue(int c)
{
    int seendot = (c == '.');
    int seenexp = 0;
    int last = c;
    int nd = 0;
    int asNumeric = 0;
    int count = 1; /* The number of characters seen */

    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    /* We don't care about other than ASCII digits */
    while (isdigit(c = xxgetc()) || c == '.' || c == 'e' || c == 'E'
	   || c == 'x' || c == 'X' || c == 'L')
    {
	count++;
	if (c == 'L') /* must be at the end.  Won't allow 1Le3 (at present). */
	    break;

	if (c == 'x' || c == 'X') {
	    if (count > 2 || last != '0') break;  /* 0x must be first */
	    YYTEXT_PUSH(c, yyp);
	    while(isdigit(c = xxgetc()) || ('a' <= c && c <= 'f') ||
		  ('A' <= c && c <= 'F') || c == '.') {
		YYTEXT_PUSH(c, yyp);
		nd++;
	    }
	    if (nd == 0) return ERROR;
	    if (c == 'p' || c == 'P') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c) && c != '+' && c != '-') return ERROR;
		if (c == '+' || c == '-') {
		    YYTEXT_PUSH(c, yyp);
		    c = xxgetc();
		}
		for(nd = 0; isdigit(c); c = xxgetc(), nd++)
		    YYTEXT_PUSH(c, yyp);
		if (nd == 0) return ERROR;
	    }
	    break;
	}
	if (c == 'E' || c == 'e') {
	    if (seenexp)
		break;
	    seenexp = 1;
	    seendot = seendot == 1 ? seendot : 2;
	    YYTEXT_PUSH(c, yyp);
	    c = xxgetc();
	    if (!isdigit(c) && c != '+' && c != '-') return ERROR;
	    if (c == '+' || c == '-') {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
		if (!isdigit(c)) return ERROR;
	    }
	}
	if (c == '.') {
	    if (seendot)
		break;
	    seendot = 1;
	}
	YYTEXT_PUSH(c, yyp);
	last = c;
    }
    YYTEXT_PUSH('\0', yyp);
    /* Make certain that things are okay. */
    if(c == 'L') {
	double a = R_atof(yytext);
	int b = (int) a;
	/* We are asked to create an integer via the L, so we check that the
	   double and int values are the same. If not, this is a problem and we
	   will not lose information and so use the numeric value.
	*/
	if(a != (double) b) {
            if(seendot == 1 && seenexp == 0)
		warning(_("integer literal %sL contains decimal; using numeric value"), yytext);
	    else
		warning(_("non-integer value %s qualified with L; using numeric value"), yytext);
	    asNumeric = 1;
	    seenexp = 1;
	}
    }

    if(c == 'i') {
	next_token_val = mkComplex(yytext);
    } else if(c == 'L' && asNumeric == 0) {
	if (seendot == 1 && seenexp == 0)
	    warning(_("integer literal %sL contains unnecessary decimal point"), yytext);
	next_token_val = mkInteger(yytext);
#if 0  /* do this to make 123 integer not double */
    } else if(!(seendot || seenexp)) {
	if(c != 'L') xxungetc(c);
	double a = R_atof(yytext);
	int b = (int) a;
	next_token_val = (a != (double) b) ? mkReal(yytext) : mkInteger(yytext);
#endif
    } else {
	if(c != 'L')
	    xxungetc(c);
	next_token_val = mkReal(yytext);
    }

    return NUM_CONST;
}


/* Strings may contain the standard ANSI escapes and octal specifications of 
   the form \o, \oo or \ooo, where 'o' is an octal digit. 

   If a string contains \u escapes that are not valid in the current locale, 
   we should switch to UTF-8 for that string.  Needs Unicode wide-char support.
*/

static int mbcs_get_next(int c, wchar_t *wc)
{
    int i, res, clen = 1; char s[9];
    mbstate_t mb_st;

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    s[i] = xxgetc();
	    if(s[i] == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), ParseState.xxlineno);
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbrtowc(wc, s, clen, NULL);
	if(res == -1) error(_("invalid multibyte character in parser at line %d"), ParseState.xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    mbs_init(&mb_st);
	    res = mbrtowc(wc, s, clen, &mb_st);
	    if(res >= 0) break;
	    if(res == -1)
		error(_("invalid multibyte character in parser at line %d"), ParseState.xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if(c == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), ParseState.xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#if defined(Win32) || defined(__STDC_ISO_10646__)

#define mbcs_get_next2 mbcs_get_next
typedef wchar_t ucs_t;

#else

#define WC_NOT_UNICODE 
typedef unsigned int ucs_t;

static int mbcs_get_next2(int c, ucs_t *wc)
{
    int i, res, clen = 1; char s[9];

    s[0] = c;
    /* This assumes (probably OK) that all MBCS embed ASCII as single-byte
       lead bytes, including control chars */
    if((unsigned int) c < 0x80) {
	*wc = (wchar_t) c;
	return 1;
    }
    if(utf8locale) {
	clen = utf8clen(c);
	for(i = 1; i < clen; i++) {
	    s[i] = xxgetc();
	    if(s[i] == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), ParseState.xxlineno);
	}
	s[clen] ='\0'; /* x86 Solaris requires this */
	res = mbtoucs(wc, s, clen);
	if(res == -1) error(_("invalid multibyte character in parser at line %d"), ParseState.xxlineno);
    } else {
	/* This is not necessarily correct for stateful MBCS */
	while(clen <= MB_CUR_MAX) {
	    res = mbtoucs(wc, s, clen);
	    if(res >= 0) break;
	    if(res == -1)
		error(_("invalid multibyte character in parser at line %d"), ParseState.xxlineno);
	    /* so res == -2 */
	    c = xxgetc();
	    if(c == R_EOF) error(_("EOF whilst reading MBCS char at line %d"), ParseState.xxlineno);
	    s[clen++] = c;
	} /* we've tried enough, so must be complete or invalid by now */
    }
    for(i = clen - 1; i > 0; i--) xxungetc(s[i]);
    return clen;
}

#endif


static SEXP mkStringUTF8(const ucs_t *wcs, int cnt)
{
    SEXP t;
    int nb;

/* NB: cnt includes the terminator */
#ifdef Win32
    nb = cnt*4; /* UCS-2/UTF-16 so max 4 bytes per wchar_t */
#else
    nb = cnt*6;
#endif
    char s[nb];
    R_CheckStack();
    memset(s, 0, nb); /* safety */
#ifdef WC_NOT_UNICODE
    {
	char *ss;
	for(ss = s; *wcs; wcs++) ss += ucstoutf8(ss, *wcs);
    }
#else
    wcstoutf8(s, wcs, nb);
#endif
    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharCE(s, CE_UTF8));
    UNPROTECT(1);
    return t;
}


static SEXP mkString2(const char *s, int len, Rboolean escaped)
{
    SEXP t;
    cetype_t enc = CE_NATIVE;

    if(known_to_be_latin1) enc= CE_LATIN1;
    else if(!escaped && known_to_be_utf8) enc = CE_UTF8;

    PROTECT(t = allocVector(STRSXP, 1));
    SET_STRING_ELT(t, 0, mkCharLenCE(s, len, enc));
    UNPROTECT(1);
    return t;
}


/* forSymbol is true when parsing backticked symbols */

static int StringValue(int c, Rboolean forSymbol)
{
    int quote = c;
    Rboolean oct_or_hex = FALSE, use_wcs = FALSE;

    char st0[MAXELTSIZE];
    unsigned int nstext = MAXELTSIZE;
    char *stext = st0, *bp = st0;

#   define STEXT_PUSH(c) do {              \
	unsigned int nc = bp - stext;       \
	if (nc >= nstext - 1) {             \
	    char *old = stext;              \
	    nstext *= 2;                    \
	    stext = malloc(nstext);         \
	    if (!stext)                     \
               error(_("unable to allocate buffer for long string at line %d"), ParseState.xxlineno); \
	    memmove(stext, old, nc);        \
	    if(old != st0) free(old);	    \
	    bp = stext+nc; }		    \
	*bp++ = (c);                        \
    } while(0)

    int wcnt = 0;
    ucs_t wcs[10001];

#   define WTEXT_PUSH(c) do { if(wcnt < 10000) wcs[wcnt++] = c; } while(0)

    char currtext[1010], *ct = currtext;

#   define CTEXT_PUSH(c) do {                     \
	if (ct - currtext >= 1000) {              \
            memmove(currtext, currtext+100, 901); \
            memmove(currtext, "... ", 4);         \
            ct -= 100;                            \
        }                                         \
	*ct++ = (c);                              \
    } while(0)

#   define CTEXT_POP() (ct--)

    while ((c = xxgetc()) != R_EOF && c != quote) {
	CTEXT_PUSH(c);
	if (c == '\n') {
	    xxungetc(c);
	    /* Fix suggested by Mark Bravington to allow multiline strings
	     * by pretending we've seen a backslash. Was:
	     * return ERROR;
	     */
	    c = '\\';
	}
	if (c == '\\') {
	    c = xxgetc(); CTEXT_PUSH(c);
	    if ('0' <= c && c <= '7') {
		int octal = c - '0';
		if ('0' <= (c = xxgetc()) && c <= '7') {
		    CTEXT_PUSH(c);
		    octal = 8 * octal + c - '0';
		    if ('0' <= (c = xxgetc()) && c <= '7') {
			CTEXT_PUSH(c);
			octal = 8 * octal + c - '0';
		    } else {
			xxungetc(c);
			CTEXT_POP();
		    }
		} else {
		    xxungetc(c);
		    CTEXT_POP();
		}
		c = octal;
		oct_or_hex = TRUE;
	    }
	    else if(c == 'x') {
		int val = 0; int i, ext;
		for(i = 0; i < 2; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \x */
			    *ct = '\0';
			    errorcall(R_NilValue, 
                             _("'\\x' used without hex digits in character string starting \"%s\""), 
                             currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		c = val;
		oct_or_hex = TRUE;
	    }
	    else if(c == 'u') {
		unsigned int val = 0; int i, ext; 
		Rboolean delim = FALSE;

		if(forSymbol) 
		    error(
                      _("\\uxxxx sequences not supported inside backticks (line %d)"), 
                      ParseState.xxlineno);
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		} else xxungetc(c);
		for(i = 0; i < 4; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \u */
			    *ct = '\0';
			    errorcall(R_NilValue, 
                              _("'\\u' used without hex digits in character string starting \"%s\""), 
                              currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    if((c = xxgetc()) != '}')
			error(_("invalid \\u{xxxx} sequence (line %d)"),
			      ParseState.xxlineno);
		    else CTEXT_PUSH(c);
		}
		WTEXT_PUSH(val); /* this assumes wchar_t is Unicode */
		use_wcs = TRUE;
		continue;
	    }
	    else if(c == 'U') {
		unsigned int val = 0; int i, ext;
		Rboolean delim = FALSE;
		if(forSymbol) 
		    error(
                      _("\\Uxxxxxxxx sequences not supported inside backticks (line %d)"), 
                      ParseState.xxlineno);
		if((c = xxgetc()) == '{') {
		    delim = TRUE;
		    CTEXT_PUSH(c);
		} else xxungetc(c);
		for(i = 0; i < 8; i++) {
		    c = xxgetc(); CTEXT_PUSH(c);
		    if(c >= '0' && c <= '9') ext = c - '0';
		    else if (c >= 'A' && c <= 'F') ext = c - 'A' + 10;
		    else if (c >= 'a' && c <= 'f') ext = c - 'a' + 10;
		    else {
			xxungetc(c);
			CTEXT_POP();
			if (i == 0) { /* was just \U */
			    *ct = '\0';
			    errorcall(R_NilValue, 
                              _("'\\U' used without hex digits in character string starting \"%s\""),
                              currtext);
			}
			break;
		    }
		    val = 16*val + ext;
		}
		if(delim) {
		    if((c = xxgetc()) != '}')
			error(_("invalid \\U{xxxxxxxx} sequence (line %d)"), 
                              ParseState.xxlineno);
		    else CTEXT_PUSH(c);
		}
		WTEXT_PUSH(val);
		use_wcs = TRUE;
		continue;
	    }
	    else {
		switch (c) {
		case 'a':
		    c = '\a';
		    break;
		case 'b':
		    c = '\b';
		    break;
		case 'f':
		    c = '\f';
		    break;
		case 'n':
		    c = '\n';
		    break;
		case 'r':
		    c = '\r';
		    break;
		case 't':
		    c = '\t';
		    break;
		case 'v':
		    c = '\v';
		    break;
		case '\\':
		    c = '\\';
		    break;
		case '"':
		case '\'':
		case ' ':
		case '\n':
		    break;
		default:
		    *ct = '\0';
		    errorcall(R_NilValue, 
                       _("'\\%c' is an unrecognized escape in character string starting \"%s\""), 
                       c, currtext);
		}
	    }
	} else if(mbcslocale) {
	    int i, clen;
	    ucs_t wc;
	    clen = mbcs_get_next2(c, &wc);
	    WTEXT_PUSH(wc);
	    for(i = 0; i < clen - 1; i++){
		STEXT_PUSH(c);
		c = xxgetc();
		if (c == R_EOF) break;
		CTEXT_PUSH(c);
		if (c == '\n') {
		    xxungetc(c); CTEXT_POP();
		    c = '\\';
		}
	    }
	    if (c == R_EOF) break;
	    STEXT_PUSH(c);
	    continue;
	}
	STEXT_PUSH(c);
	if ((unsigned int) c < 0x80) WTEXT_PUSH(c);
	else { /* have an 8-bit char in the current encoding */
#           ifdef WC_NOT_UNICODE
	        ucs_t wc;
                char s[2] = " ";
                s[0] = c;
                mbtoucs(&wc, s, 2);
#           else
                wchar_t wc;
                char s[2] = " ";
                s[0] = c;
                mbrtowc(&wc, s, 2, NULL);
#           endif
	    WTEXT_PUSH(wc);
	}
    }
    STEXT_PUSH('\0');
    WTEXT_PUSH(0);
    if (c == R_EOF) {
        if(stext != st0) free(stext);
        next_token_val = R_NilValue;
    	return ERROR;
    }
    if(forSymbol) {
	next_token_val = install(stext);
	if(stext != st0) free(stext);
	return SYMBOL;
    } else {
	if(use_wcs) {
	    if(oct_or_hex)
		error(_("mixing Unicode and octal/hex escapes in a string is not allowed"));
	    if(wcnt < 10000)
		next_token_val = mkStringUTF8(wcs, wcnt); /* include terminator */
	    else
		error(_("string at line %d containing Unicode escapes not in this locale\nis too long (max 10000 chars)"),
                      ParseState.xxlineno);
	} else
	    next_token_val = mkString2(stext,  bp - stext - 1, oct_or_hex);
	if(stext != st0) free(stext);
	return STR_CONST;
    }
}


/* --------------------------------------------------------------------------
   THE LEXICAL ANALYZER
*/

/* Table of syntactic keywords and symbolic constants. */

static struct { char *name; int token; } keywords[] = {
    { "NULL",	    NULL_CONST },
    { "NA",	    NUM_CONST  },  /* order of next 9 is significant below */
    { "TRUE",	    NUM_CONST  },
    { "FALSE",	    NUM_CONST  },
    { "Inf",	    NUM_CONST  },
    { "NaN",	    NUM_CONST  },
    { "NA_integer_", NUM_CONST  },
    { "NA_real_",    NUM_CONST  },
    { "NA_character_", NUM_CONST  },
    { "NA_complex_", NUM_CONST  },
    { "function",   FUNCTION   },
    { "while",	    WHILE      },
    { "repeat",	    REPEAT     },
    { "for",	    FOR	       },
    { "if",	    IF	       },
    { "in",	    IN	       },
    { "else",	    ELSE       },
    { "next",	    NEXT       },
    { "break",	    BREAK      },
    { "...",	    SYMBOL     },
    { 0,	    0	       }
};


/* Check whether a string is a keyword.  Returns 0 if it is not a keyword.
   Returns 1 if it is a keyword, and also sets next_token_val to the
   associated value (constant, symbol, or R_NilValue for 'in' and 'else'). */

static int KeywordLookup(const char *s)
{
    int i;
    for (i = 0; keywords[i].name; i++) {
	if (strcmp(keywords[i].name, s) == 0) {
	    switch (keywords[i].token) {
	    case NULL_CONST:
		next_token_val = R_NilValue;
		break;
	    case NUM_CONST:
                switch(i) {
                case 1:
                    next_token_val = ScalarLogicalMaybeConst(NA_LOGICAL);
                    break;
                case 2:
                    next_token_val = ScalarLogicalMaybeConst(1);
                    break;
                case 3:
                    next_token_val = ScalarLogicalMaybeConst(0);
                    break;
                case 4:
                    next_token_val = allocVector1REAL();
                    REAL(next_token_val)[0] = R_PosInf;
                    break;
                case 5:
                    next_token_val = allocVector1REAL();
                    REAL(next_token_val)[0] = R_NaN;
                    break;
                case 6:
                    next_token_val = ScalarIntegerMaybeConst(NA_INTEGER);
                    break;
                case 7:
                    next_token_val = allocVector1REAL();
                    REAL(next_token_val)[0] = NA_REAL;
                    break;
                case 8:
                    next_token_val = allocVector(STRSXP, 1);
                    SET_STRING_ELT(next_token_val, 0, NA_STRING);
                    break;
                case 9:
                    next_token_val = allocVector(CPLXSXP, 1);
                    COMPLEX(next_token_val)[0].r = NA_REAL;
                    COMPLEX(next_token_val)[0].i = NA_REAL;
                    break;
                }
		break;
	    case FUNCTION:
		next_token_val = R_FunctionSymbol;
		break;
	    case WHILE:
		next_token_val = R_WhileSymbol;
		break;
	    case REPEAT:
		next_token_val = R_RepeatSymbol;
		break;
	    case FOR:
		next_token_val = R_ForSymbol;
		break;
	    case IF:
		next_token_val = R_IfSymbol;
		break;
	    case NEXT:
		next_token_val = R_NextSymbol;
		break;
	    case BREAK:
		next_token_val = R_BreakSymbol;
		break;
		break;
	    case IN:
	    case ELSE:
		next_token_val = R_NilValue;
		break;
	    case SYMBOL:
		next_token_val = install(s);
		break;
	    }
	    return keywords[i].token;
	}
    }
    return 0;
}


/* Process a special operator beginning with '%', setting next_token_val
   to a symbol for it.  The value returned is SYMBOL or ERROR (if operator
   is incomplete). */

static int SpecialValue(int c)
{
    DECLARE_YYTEXT_BUFP(yyp);
    YYTEXT_PUSH(c, yyp);
    while ((c = xxgetc()) != R_EOF && c != '%') {
	if (c == '\n') {
	    xxungetc(c);
	    return ERROR;
	}
	YYTEXT_PUSH(c, yyp);
    }
    if (c == '%')
	YYTEXT_PUSH(c, yyp);
    YYTEXT_PUSH('\0', yyp);
    next_token_val = install(yytext);
    return SPECIAL;
}


/* Process a symbol value, putting the symbol in next_token_val (or
   the corresponding numeric or logical value, for constants).  The
   return value is SYMBOL for regular symbols, NUM_CONST for constants,
   and the appropriate token code for reserved words. */

static int SymbolValue(int c)
{
    int kw;
    DECLARE_YYTEXT_BUFP(yyp);
    if(mbcslocale) {
	wchar_t wc; int i, clen;
	clen = mbcs_get_next(c, &wc);
	while(1) {
	    /* at this point we have seen one char, so push its bytes
	       and get one more */
	    for(i = 0; i < clen; i++) {
		YYTEXT_PUSH(c, yyp);
		c = xxgetc();
	    }
	    if(c == R_EOF) break;
	    if(c == '.' || c == '_') {
		clen = 1;
		continue;
	    }
	    clen = mbcs_get_next(c, &wc);
	    if(!iswalnum(wc)) break;
	}
    } else
	do {
	    YYTEXT_PUSH(c, yyp);
	} while ((c = xxgetc()) != R_EOF &&
		 (isalnum(c) || c == '.' || c == '_'));
    xxungetc(c);
    YYTEXT_PUSH('\0', yyp);
    if ((kw = KeywordLookup(yytext))) 
	return kw;
    
    next_token_val = install(yytext);
    return SYMBOL;
}


/* Skip whitespace characters.  The argument says whether or not to stop
   when a newline is encountered.  Sets newline_before_token to 1 if
   a newline is found (but doesn't set it to 0 if not). */

static int SkipSpace(int stop_on_nl)
{
    int NBSP = ' ';

#if defined(Win32) || defined(__STDC_ISO_10646__)
    int i, clen;
    wchar_t wc;  /* wctype functions need Unicode wchar_t */
#endif

#ifdef Win32
    if (!mbcslocale) NBSP = 0xa0; /* 0xa0 is NBSP in 8-bit Windows locales */
#endif 

    int c;

    while (1) {

        c = xxgetc();

        if (c == ' ' || c == '\t' || c == '\f' || c == NBSP) 
            continue;

        if (c == '\n') { 
            if (stop_on_nl) break;
            newline_before_token = 1;
            continue;
        }

        if (c == R_EOF)
            break;

#       if defined(Win32) || defined(__STDC_ISO_10646__)
            if (mbcslocale) {
                if ((unsigned int) c < 0x80)
                    break;
                clen = mbcs_get_next(c, &wc);
                if ( ! Ri18n_iswctype (wc, Ri18n_wctype("blank")))
                    break;
                for (i = 1; i < clen; i++)
                    c = xxgetc();
            }
#       endif

        break;
    }

    return c;
}


/* Set the name of the source file that text is coming from. */

static void setParseFilename(SEXP newname) {

    SEXP class;
    PROTECT(newname);    

    if (isEnvironment(ParseState.SrcFile)) {
    	SEXP oldname = findVar(install("filename"), ParseState.SrcFile);
    	if (isString(oldname) && length(oldname) > 0 &&
    	    strcmp(CHAR(STRING_ELT(oldname, 0)),
    	           CHAR(STRING_ELT(newname, 0))) == 0) return;
	REPROTECT(ParseState.SrcFile =
                    NewEnvironment (R_NilValue, R_NilValue, R_EmptyEnv),
                  ParseState.SrcFileProt);
	defineVar(install("filename"), newname, ParseState.SrcFile);
    }

    if (ParseState.keepSrcRefs) {
	defineVar(install("original"), ParseState.Original, ParseState.SrcFile);
        PROTECT(class = allocVector(STRSXP, 2));
        SET_STRING_ELT(class, 0, mkChar("srcfilealias"));
        SET_STRING_ELT(class, 1, mkChar("srcfile"));
	setAttrib(ParseState.SrcFile, R_ClassSymbol, class);
        UNPROTECT(1);
    } 

    UNPROTECT(1);
}


/* Process a #line nn [ file ] directive.  The #line part will have already
   been read.  Returns the character after the directive. */

static int processLineDirective()
{
    int c, tok, linenumber;

    c = SkipSpace(1);
    if (!isdigit(c)) return(c);

    tok = NumericValue(c);
    linenumber = atoi(yytext);
    c = SkipSpace(1);
    if (c == '"') 
        tok = StringValue(c, FALSE);
    else
    	xxungetc(c);
    if (tok == STR_CONST) 
	setParseFilename(next_token_val);

    while ((c = xxgetc()) != '\n' && c != R_EOF) /* skip */ ;

    ParseState.xxlineno = linenumber;

    /* Don't change xxparseno here, it counts parsed lines, not official lines*/

    /* Context report shouldn't show the directive */

    R_ParseContext[R_ParseContextLast] = '\0'; 

    return(c);
}


/* Skip a comment, returning the character ending it ('\n' or R_EOF).  
   Also processes comments that are #line directives. */

static int SkipComment(void)
{
    int c='#', i;
    Rboolean maybeLine = (ParseState.xxcolno == 1);
    if (maybeLine) {
    	static const char lineDirective[] = "#line";
    	for (i=1; i<5; i++) {
    	    c = xxgetc();
  	    if (c != (int)(lineDirective[i])) {
  	    	maybeLine = FALSE;
  	    	break;
  	    }
  	}
  	if (maybeLine)     
	    c = processLineDirective();
    }
    while (c != '\n' && c != R_EOF) 
	c = xxgetc();
    return c;
}


/* Called following '.'.  We only care if it's an ANSI digit or not */

static int nextisdigit(void)
{
    int k, c;
    c = xxgetc();
    k = isdigit(c);
    xxungetc(c);
    return k;
}


/* Returns whether the next character is the one passed, advancing to
   the next character only if it is. */

static int nextchar(int expect)
{
    int c = xxgetc();
    if (c == expect)
	return 1;
    else {
	xxungetc(c);
        return 0;
    }
}


/* Get a token.

   Passed the first non-whitespace character of the next token.  Returns
   the token code (or ERROR if the next token is malformed).  Will also
   set next_token_val to an associated SEXP (R_NilValue if none).  This
   SEXP must be protected by the caller if necessary.

   The character after the token may have been looked at, but if so xxungetc
   will have been called to put it back. */

static int token (int c)
{
    wchar_t wc;

    next_token_val = R_NilValue;

    /* Hard and soft end of file.  Soft end of file comes at the end of a
       line of interactive input, which may or may not be the actual end. */

    if (c == R_EOF) {
        newline_before_token = 1;
        return END_OF_INPUT;
    }

    if (c == SOFT_EOF) {
        newline_before_token = 1;
        return MAYBE_END;
    }

    /* Literal numbers - since either digits or symbols can start with '.',
       we need to check whether the next character is a digit. */

    if (isdigit(c) || c == '.' && nextisdigit())
        return NumericValue(c);

    /* Literal strings */

    if (c == '\"' || c == '\'')
	return StringValue(c, FALSE);

    /* Special functions */

    if (c == '%')
	return SpecialValue(c);

    /* Symbols (functions, constants and variables) */

    if (c == '`')
	return StringValue(c, TRUE);
    if (c == '.') 
        return SymbolValue(c);
    if(mbcslocale) {
	mbcs_get_next(c, &wc);
	if (iswalpha(wc)) return SymbolValue(c);
    }
    else
	if (isalpha(c)) return SymbolValue(c);

    /* Simple and compound tokens */

    switch (c) {
    case '<':
	if (nextchar('=')) {
	    next_token_val = R_LeSymbol;
	    return LE;
	}
	if (nextchar('-')) {
	    next_token_val = R_LocalAssignSymbol;
	    return LEFT_ASSIGN;
	}
	if (nextchar('<')) {
	    if (nextchar('-')) {
		next_token_val = R_GlobalAssignSymbol;
		return LEFT_ASSIGN;
	    }
	    else
		return ERROR;
	}
	next_token_val = R_LtSymbol;
	return LT;
    case '-':
	if (nextchar('>')) {
	    if (nextchar('>')) {
		next_token_val = R_GlobalAssignSymbol; /* switch R to L */
		return RIGHT_ASSIGN;
	    }
	    else {
		next_token_val = R_LocalAssignSymbol;  /* switch R to L */
		return RIGHT_ASSIGN;
	    }
	}
	next_token_val = R_SubSymbol;
	return '-';
    case '>':
	if (nextchar('=')) {
	    next_token_val = R_GeSymbol;
	    return GE;
	}
	next_token_val = R_GtSymbol;
	return GT;
    case '!':
	if (nextchar('=')) {
	    next_token_val = R_NeSymbol;
	    return NE;
	}
	next_token_val = R_NotSymbol;
	return '!';
    case '=':
	if (nextchar('=')) {
	    next_token_val = R_EqSymbol;
	    return EQ;
	}
	next_token_val = R_EqAssignSymbol;
	return EQ_ASSIGN;
    case ':':
	if (nextchar(':')) {
	    if (nextchar(':')) {
		next_token_val = R_TripleColonSymbol;
		return NS_GET_INT;
	    }
	    else {
		next_token_val = R_DoubleColonSymbol;
		return NS_GET;
	    }
	}
	if (nextchar('=')) {
	    next_token_val = R_ColonEqSymbol;
	    return LEFT_ASSIGN;
	}
	next_token_val = R_ColonSymbol;
	return ':';
    case '&':
	if (nextchar('&')) {
	    next_token_val = R_And2Symbol;
	    return AND2;
	}
	next_token_val = R_AndSymbol;
	return AND;
    case '|':
	if (nextchar('|')) {
	    next_token_val = R_Or2Symbol;
	    return OR2;
	}
	next_token_val = R_OrSymbol;
	return OR;
    case '{':
	next_token_val = R_BraceSymbol;
	return c;
    case '}':
	return c;
    case '(':
	next_token_val = R_ParenSymbol;
	return c;
    case ')':
	return c;
    case '[':
	if (nextchar('[')) {
	    next_token_val = R_Bracket2Symbol;
	    return LBB;
	}
	next_token_val = R_BracketSymbol;
	return c;
    case ']':
	return c;
    case '?':
	next_token_val = R_QuerySymbol;
	return c;
    case '*':
	/* Replace ** by ^.  This has been here since 1998, but is
	   undocumented (at least in the obvious places).  It is in
	   the index of the Blue Book with a reference to p. 431, the
	   help for 'Deprecated'.  S-PLUS 6.2 still allowed this, so
	   presumably it was for compatibility with S. */
	if (nextchar('*')) {
	    next_token_val = R_ExptSymbol;  /* replace by ^ for now */
            return '^';
        }
        next_token_val = R_MulSymbol;
	return c;
    case '+':
        next_token_val = R_AddSymbol;
        return c;
    case '/':
        next_token_val = R_DivSymbol;
        return c;
    case '^':
        next_token_val = R_ExptSymbol;
        return c;
    case '~':
        next_token_val = R_TildeSymbol;
        return c;
    case '$':
        next_token_val = R_DollarSymbol;
        return c;
    case '@':
        next_token_val = R_AtSymbol;
        return c;
    default:
	return c;
    }
}


/* Get the next token (after skipping whitespace) and put it in 
   next_token.  Also sets next_token_val, newline_before_token, 
   token_loc, and prev_token_loc. */

static void get_next_token(void)
{
    int c;

    prev_token_loc = token_loc;

    newline_before_token = 0;
    c = SkipSpace(0);
    while (c == '#') {
        c = SkipComment();
        if (c == '\n') {
            newline_before_token = 1;
            c = SkipSpace(0);
        }
    }

    token_loc.first_line = ParseState.xxlineno;
    token_loc.first_column = ParseState.xxcolno;
    token_loc.first_byte = ParseState.xxbyteno;
    token_loc.first_parsed = ParseState.xxparseno;

    next_token = token(c);

    token_loc.last_line   = ParseState.xxlineno;
    token_loc.last_column = ParseState.xxcolno;
    token_loc.last_byte   = ParseState.xxbyteno;
    token_loc.last_parsed = ParseState.xxparseno;
}


/* --------------------------------------------------------------------------
   ROUTINE USED ONLY EXTERNALLY
*/

/* Return 1 if 'name' is a valid name or 0 otherwise.  Not used by the
   parser itself, but defined here since it needs to know which names 
   are reserved words. */

int isValidName(const char *name)
{
    const char *p = name;
    int i;

    if(mbcslocale) {
	/* the only way to establish which chars are alpha etc is to
	   use the wchar variants */
	int n = strlen(name), used;
	wchar_t wc;
	used = Mbrtowc(&wc, p, n, NULL); p += used; n -= used;
	if(used == 0) return 0;
	if (wc != L'.' && !iswalpha(wc) ) return 0;
	if (wc == L'.') {
	    /* We don't care about other than ASCII digits */
	    if(isdigit(0xff & (int)*p)) return 0;
	    /* Mbrtowc(&wc, p, n, NULL); if(iswdigit(wc)) return 0; */
	}
	while((used = Mbrtowc(&wc, p, n, NULL))) {
	    if (!(iswalnum(wc) || wc == L'.' || wc == L'_')) break;
	    p += used; n -= used;
	}
	if (*p != '\0') return 0;
    } else {
	int c = 0xff & *p++;
	if (c != '.' && !isalpha(c) ) return 0;
	if (c == '.' && isdigit(0xff & (int)*p)) return 0;
	while ( c = 0xff & *p++, (isalnum(c) || c == '.' || c == '_') ) ;
	if (c != '\0') return 0;
    }

    if (strcmp(name, "...") == 0) return 1;

    /* Check whether it's a reserved word. */

    for (i = 0; keywords[i].name != NULL; i++)
	if (strcmp(keywords[i].name, name) == 0) return 0;

    return 1;
}
